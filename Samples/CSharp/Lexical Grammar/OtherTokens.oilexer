#include                      "Root.oilexer";

#ifdef Lexer
#if Lexer == "CSPreprocessor"

Token$ :=
    Identifier                              |
    Keywords                                |
    Literal                                 |
    OperatorOrPunctuator                    |
    IntegralDataTypes                       |
    Modifiers                               ;
    
#endif
#endif 

Literal :=
    Number                                  |
    String                                  |
    Char                                    ;

BooleanLiteral :=
    "true":TrueValue;                       |
   "false":FalseValue;                      ;

Char := '\'' CharBody '\'';

CharBody := 
    CharEscape                              |
    CommonEscapes                           |
    [^'\\]                                  ;

CharEscape := '\\' "'";

String := 
    '"' StringChar* '"'                     | 
    '@' '"' ('"' '"' | [^"])* '"';

StringChar := 
    CommonEscapes                           | 
    StringEscape                            | 
    [^"\\\r\n];

StringEscape := '\\' '"';

CommonEscapes :=
    '\\' ('f' /* Form Feed */               |
          'v' /* Vertical Tab */            |
          't' /* Horizontal Tab */          |
          'r' /* Carriage Return */         |
          'n' /* New line */                |
          '0' /* Null Char */               |
          '\\' /* Backslash Escape */       |
          HexEscape /* Hexadecimal Escape */|
          OctEscape /* Octal Escape */      |
          ErrEscape /* Errored escape */);
#ifdef Lexer
#if Lexer == "CSPreprocessor"
Identifier := 
    '@'? IdentifierOrKeyword;
#else
Identifier := 
    Subtract(IdentifierOrKeyword, Keywords | Modifiers | IntegralDataTypes) |
    '@'IdentifierOrKeyword;
#endif
#endif

/*
IdentifierChar := [A-Z_a-z];

Identifier := '@' IdentifierChar+ (IdentifierChar | [0-9])* |
    Subtract(IdentifierChar+ (IdentifierChar | [0-9])*, Keywords);
//*/

UnicodeEscapeSequence :=
    "\\u" HexChar{4};

IdentifierOrKeyword :=
    IdentifierStartCharacter IdentifierPartCharacter*;

IdentifierStartCharacter :=
    LetterCharacter                         |
    '_'                                     |
    UnicodeEscapeSequence                   ;

IdentifierPartCharacter :=
    LetterCharacter                         |
    CombiningCharacter                      |
    DecimalDigitCharacter                   |
    ConnectingCharacter                     |
    CombiningCharacter                      |
    FormattingCharacter                     |
    UnicodeEscapeSequence                   ;

LetterCharacter :=
    [:Lu::Ll::Lt::Lm::Lo::Nl:];

CombiningCharacter :=
    [:Mn::Mc:];

DecimalDigitCharacter :=
    [:Nd:];

ConnectingCharacter :=
    [:Pc:];

FormattingCharacter :=
    [:Cf:];
    
ErrEscape := [^fvntrux\\"']:ECapt; /*{ThrowError(InvalidEscape, ECapt);}*/; 

OctEscape := [0-7]{3};

HexChar := [0-9A-Fa-f];

HexEscape := HexByteEscape | HexShortEscape;

HexByteEscape := 'x' HexChar{2};

HexShortEscape := 'u' HexChar{4};

DecimalNumber := 
    [0-9]+;
    
Number := 
    "0x" HexChar:WholePart;+  
    (
        @'U':Unsigned; @'L':Long;?          | 
        @'L':Long; @'U':Unsigned;?
    ):ValueType;? |
    DecimalNumber:WholePart;+ 
    (
        (
            @'U':Unsigned; @'L':Long;?      | 
            @'L':Long; @'U':Unsigned;?      | 
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;                        | 
        '.' DecimalNumber:FloatingPart;+ 
        (
            @'e' 
            (
                '+':Positive;               | 
                '-':Negative;
            ):Sign;Default=Positive;? 
            DecimalNumber:Value;+
        ):Exponent;? 
        (
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;Default=Double;?
    )?;

Comment :=*
    SingleLineComment                       | 
    RangeComment                            ; 

#ifdef Lexer
#if Lexer == "CSPreprocessor"

Whitespace :=
    [:Zs:]                                  | 
    '\u0009'                                | 
    '\v'                                    | 
    '\t'                                    |
    '\f'                                    ; 

#elif Lexer == "CSParser"
Whitespace :=*
    ([:Zs:]                                 | 
    '\u0009'                                | 
    '\v'                                    | 
    '\t'                                    |
    '\f'                                    |
    NewLine)+; 
#endif
#endif

SingleLineComment := 
    "//" NotNewLineCharacter*;
 
RangeComment :=
    "/*" Scan("*/", true);
    
NewLine :=
    '\r'                                    | 
    '\n'                                    | 
    "\r\n"                                  | 
    '\u0085'                                | 
    '\u2028'                                | 
    '\u2029'                                ; 

NotNewLineCharacter :=
    [^\r\n\u0085\u2028\u2029];
