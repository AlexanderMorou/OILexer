#include                      "ToyTokens.oilexer";

#ifdef Lexer
#if Lexer == "ToyPreprocessor"

Token$ :=
    Identifier                              |
    Keywords                                |
    Literal                                 |
    OperatorOrPunctuator                    |
    IntegralDataTypes                       |
    Modifiers                               |
    PreprocessorCharacterRange              ;
    
#endif
#endif 

Literal :=
    Number                                  |
    String                                  |
    Char                                    ;

BooleanLiteral :=
    "true":TrueValue;                       |
   "false":FalseValue;                      ;

Char := '\'' CharBody '\'';

CharBody := 
    CharEscape                              |
    CommonEscapes                           |
    [^'\\]                                  ;

CharEscape := '\\' "'";

String := 
    '"' StringChar* '"'                     | 
    '@' '"' ('"' '"' | [^"])* '"';

StringChar := 
    CommonEscapes                           | 
    StringEscape                            | 
    [^"\\\r\n:];

StringEscape := '\\' '"';

CommonEscapes :=
    '\\' ('f' /* Form Feed */               |
          'v' /* Vertical Tab */            |
          't' /* Horizontal Tab */          |
          'r' /* Carriage Return */         |
          'n' /* New line */                |
          '0' /* Null Char */               |
          '\\' /* Backslash Escape */       |
          HexEscape /* Hexadecimal Escape */|
          OctEscape /* Octal Escape */      |
          ErrEscape /* Errored escape */)   ;

Identifier := 
    '@'? IdentifierOrKeyword;

UnicodeEscapeSequence :=
    "\\u" HexChar{4};

IdentifierOrKeyword :=
    IdentifierStartCharacter IdentifierPartCharacter*;

IdentifierStartCharacter :=
    LetterCharacter                         |
    '_'                                     |
    UnicodeEscapeSequence                   ;

IdentifierPartCharacter :=
    LetterCharacter                         |
    CombiningCharacter                      |
    DecimalDigitCharacter                   |
    ConnectingCharacter                     |
    CombiningCharacter                      |
    FormattingCharacter                     |
    UnicodeEscapeSequence                   ;

LetterCharacter :=
    [:Lu::Ll::Lt::Lm::Lo::Nl:];

CombiningCharacter :=
    [:Mn::Mc:];

DecimalDigitCharacter :=
    [:Nd:];

ConnectingCharacter :=
    [:Pc:];

FormattingCharacter :=
    [:Cf:];
    
ErrEscape := [^fvntrux\\"']:ECapt; /*{ThrowError(InvalidEscape, ECapt);}*/; 

OctEscape := [0-7]{3};

HexChar := [0-9A-Fa-f];

HexEscape := HexByteEscape | HexShortEscape;

HexByteEscape := 'x' HexChar{2};

HexShortEscape := 'u' HexChar{4};

DecimalNumber := 
    [0-9]+;
    
Number := 
    "0x" HexChar:WholePart;+  
    (
        @'U':Unsigned; @'L':Long;?          | 
        @'L':Long; @'U':Unsigned;?
    ):ValueType;? |
    DecimalNumber:WholePart;+ 
    (
        (
            @'U':Unsigned; @'L':Long;?      | 
            @'L':Long; @'U':Unsigned;?      | 
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;                        | 
        '.' DecimalNumber:FloatingPart;+ 
        (
            @'e' 
            (
                '+':Positive;               | 
                '-':Negative;
            ):Sign;Default=Positive;? 
            DecimalNumber:Value;+
        ):Exponent;? 
        (
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;Default=Double;?
    )?;

Comment :=*
    SingleLineComment                       | 
    RangeComment                            ; 

#ifdef Lexer
#if Lexer == "ToyPreprocessor"

Whitespace :=
    [:Zs:]                                  | 
    '\u0009'                                | 
    '\v'                                    | 
    '\t'                                    |
    '\f'                                    ; 

PreprocessorCharacterRange                 :=
    '[' ('^'? PreprocessorCharacterRangeEntity*  |
      PreprocessorCharacterRangeEntity* '^'?)']';

PreprocessorCharacterRangeEntity           :=
    CharacterRangeChar                      |
    CharacterRangeUnicode                   |
    CommonEscapes                           ;

#elif Lexer == "ToyParser"
Whitespace :=*
    (
        [:Zs:]                              | 
        '\u0009'                            | 
        '\v'                                | 
        '\t'                                |
        '\f'
    )+                                      |
    NewLine; 
#endif
#endif

SingleLineComment := 
    "//" NotNewLineCharacter*;
 
RangeComment :=
    "/*" Scan("*/", true);
    
NewLine :=
    '\r'                                    | 
    '\n'                                    | 
    "\r\n"                                  | 
    '\u0085'                                | 
    '\u2028'                                | 
    '\u2029'                                ; 

NotNewLineCharacter :=
    [^\r\n\u0085\u2028\u2029];

CharacterRangeUnicode                      :=
     ":Lu:":UppercaseLetter;                | //(letter, upper)
     ":Ll:":LowercaseLetter;                | //(letter, lower)
     ":Lt:":TitlecaseLetter;                | //(letter, titlecase)
     ":Lm:":ModifierLetter;                 | //(letter, modifier)
     ":Lo:":OtherLetter;                    | //(letter, other)
      ":L:":AllLetters;                     | //(letter, upper, lower, titlecase, modifier, other)
     ":Mn:":NonSpacingMark;                 | //(mark, nonspacing)
     ":Mc:":SpaceCombiningMark;             | //(mark, combining)
     ":Me:":EnclosingMark;                  | //(mark, enclosing)
      ":M:":AllMarks;                       | //(mark, nonspacing, combining, enclosing)
     ":Nd:":DecimalDigitNumber;             | //(number, decimal digit)
     ":Nl:":LetterNumber;                   | //(number, letter)
     ":No:":OtherNumber;                    | //(number, other)
      ":N:":AllNumbers;                     | //(number, decimal digit, letter, other)
     ":Zs:":SpaceSeparator;                 | //(separator, space)
     ":Zl:":LineSeparator;                  | //(separator, line)
     ":Zp:":ParagraphSeparator;             | //(separator, paragraph)
      ":Z:":AllSeparators;                  | //(separator, space, line, paragraph)
     ":Cc:":Control;                        | //(other, control)
     ":Cf:":Format;                         | //(other, format)
     ":Cs:":Surrogate;                      | //(other, surrogate)
     ":Co:":PrivateUse;                     | //(other, private use)
     ":Cn:":OtherNotAssigned;               | //(other, not assigned)
      ":C:":AllOthers;                      | //(other, control, format, surrogate, private use, and not-assigned)
     ":Pc:":ConnectorPunctuation;           | //(punctuation, connector)
     ":Pd:":DashPunctuation;                | //(punctuation, dash)
     ":Ps:":OpenPunctuation;                | //(punctuation, open /start)
     ":Pe:":ClosePunctuation;               | //(punctuation, close/end)
     ":Pi:":InitialQuotePunctuation;        | //(punctuation, initial quote)
     ":Pf:":FinalQuotePunctuation;          | //(punctuation, final quote)
     ":Po:":OtherPunctuation;               | //(punctuation, other)
      ":P:":AllPunctuation;                 | //(punctuation, connector, dash, open/start, close/end, initial quote, final quote, other)
     ":Sm:":MathSymbol;                     | //(symbol, math)
     ":Sc:":CurrencySymbol;                 | //(symbol, currency)
     ":Sk:":ModifierSymbol;                 | //(symbol, modifier)
     ":So:":OtherSymbol;                    | //(symbol, other) 
      ":S:":AllSymbols;                     ; //(symbol, math, currency, modifier, other)

CharacterRangeChar                         := 
    CharacterRangeCharEscape                |
    CommonEscapes                           |
    [^\]\r\n\\\u0085\u2028\u2029\:]          ;

CharacterRangeCharEscape                   :=
    '\\' ']'                                |
    '\\' '^'                                |
    '\\' ':'                                ;
