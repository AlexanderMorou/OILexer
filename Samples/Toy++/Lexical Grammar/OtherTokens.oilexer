#include         "TPPLexicalGrammar.oilexer";

#ifdef Lexer
#if Lexer == "TPPreprocessor"

Token$ :=
    Identifier                              |
    Keywords                                |
    Literal                                 |
    OperatorOrPunctuator                    |
    IntegralDataTypes                       |
    Modifiers                               ;
    
#endif
#endif 

Literal :=
    Number                                  |
    String                                  |
    Char                                    ;

BooleanLiteral :=
    "true":TrueValue;                       |
   "false":FalseValue;                      ;

Char := '\'' CharBody '\'';

CharBody := 
    CharEscape                              |
    CommonEscapes                           |
    [^'\\]                                  ;

CharEscape := '\\' "'";

String := 
    '"' StringChar* '"'                     | 
    '@' '"' ('"' '"' | [^"])* '"';

StringChar := 
    CommonEscapes                           | 
    StringEscape                            | 
    [^"\\\r\n];

StringEscape := '\\' '"';

CommonEscapes :=
    '\\' ('f' /* Form Feed */               |
          'v' /* Vertical Tab */            |
          't' /* Horizontal Tab */          |
          'r' /* Carriage Return */         |
          'n' /* New line */                |
          '0' /* Null Char */               |
          '\\' /* Backslash Escape */       |
          HexEscape /* Hexadecimal Escape */|
          OctEscape /* Octal Escape */      |
          ErrEscape /* Errored escape */)   ;

Identifier := 
    '@'? IdentifierOrKeyword;

UnicodeEscapeSequence :=
    "\\u" HexChar{4};

IdentifierOrKeyword :=
    IdentifierStartCharacter IdentifierPartCharacter*;

IdentifierStartCharacter :=
    LetterCharacter                         |
    '_'                                     |
    UnicodeEscapeSequence                   ;

IdentifierPartCharacter :=
    LetterCharacter                         |
    CombiningCharacter                      |
    DecimalDigitCharacter                   |
    ConnectingCharacter                     |
    CombiningCharacter                      |
    FormattingCharacter                     |
    UnicodeEscapeSequence                   ;

LetterCharacter :=
    [:Lu::Ll::Lt::Lm::Lo::Nl:];

CombiningCharacter :=
    [:Mn::Mc:];

DecimalDigitCharacter :=
    [:Nd:];

ConnectingCharacter :=
    [:Pc:];

FormattingCharacter :=
    [:Cf:];
    
ErrEscape := [^fvntrux\\"']:ECapt; /*{ThrowError(InvalidEscape, ECapt);}*/; 

OctEscape := [0-7]{3};

HexChar := [0-9A-Fa-f];

HexEscape := HexByteEscape | HexShortEscape;

HexByteEscape := 'x' HexChar{2};

HexShortEscape := 'u' HexChar{4};

DecimalNumber := 
    [0-9];
    
SeptemvigesimalChar := [0-9A-Qa-q];

OctalChar := [0-7];

CharacterRange$                            :=
    '[' '^':InvertedSet;Flag=true;? 
    (
        '-':HasHyphen;Flag=true;? 
        CharacterRangeEntry:Entries;+       | 
        CharacterRangeEntry:Entries;+ 
        '-':HasHyphen;Flag=true;?
    )
    ']'                                     ;

CharacterRangeUnicodeSet              :=
    @":L:":Letter;                          |
    @":LU:":LetterUpper;                    |
    @":LL:":LetterLowerCase;                |
    @":LT:":LetterTitleCase;                |
    @":LM:":LetterModifier;                 |
    @":LO:":LetterOther;                    |

    @":M:":Mark;                            |
    @":MN:":NonSpacing;                     |
    @":MC:":Combining;                      |
    @":ME:":Enclosing;                      |

    @":N:":Number;                          |
    @":ND:":NumberDigit;                    |
    @":NL:":NumberLetter;                   |
    @":NO:":NumberOther;                    |

    @":Z:":Separator;                       |
    @":ZS:":SeparatorSpace;                 |
    @":ZL:":SeparatorLine;                  |
    @":ZP:":SeparatorParagraph;             |

    @":C:":Other;                           |
    @":CC:":OtherControl;                   |
    @":CF:":OtherFormat;                    |
    @":CS:":OtherSurrogate;                 |
    @":CO:":OtherPrivateUse;                |
    @":CN:":OtherNotAssigned;               |

    @":P:":Punctuation;                     |
    @":PC:":PunctuationConnector;           |
    @":PD:":PunctuationDash;                |
    @":PS:":PunctuationOpenOrStart;         |
    @":PE:":PunctuationCloseOrEnd;          |
    @":PI:":PunctuationInitialQuote;        |
    @":PF:":PunctuationFinalQuote;          |
    @":PO:":PunctuationOther;               |

    @":S:":Symbol;                          |
    @":SM:":SymbolMath;                     |
    @":SC:":SymbolCurrency;                 |
    @":SK:":SymbolModifier;                 |
    @":SO:":SymbolOther;                    ;

CharacterRangeEntry                        :=
    CharacterRangeChar                      |
    CharacterRangeSet                       |
    CharacterRangeUnicodeSet                ;

CharacterRangeSet :=
    CharacterRangeChar:Start; '-' 
    CharacterRangeChar:End;                 ;

CharacterRangeChar                         :=
    [^\]\\-:] |
    '\\' (
                '\\'                        |
                ']'                         |
                '-'                         |
                ':'                         |
                HexEscape                   |
                OctEscape
             )                              ;

Number := 
    /* *
     * To ensure that the base-27 is parsed right,
     * it requires the 'U' to always be first.
     * */
    "27x" SeptemvigesimalChar:WholePart;+
    (@'U':Unsigned;? @'L':Long;?):ValueType;|
    "8x" OctalChar:WholePart;+
    (
        @'U':Unsigned; @'L':Long;?          | 
        @'L':Long; @'U':Unsigned;?          | 
        @'D':Double;                        | 
        @'F':Single;                        | 
        @'M':Decimal;
    ):ValueType;?                           | 
    "0x" HexChar:WholePart;+
    (
        @'U':Unsigned; @'L':Long;?          | 
        @'L':Long; @'U':Unsigned;?
    ):ValueType;?                           |
    DecimalNumber:WholePart;+ 
    (
        (
            @'U':Unsigned; @'L':Long;?      | 
            @'L':Long; @'U':Unsigned;?      | 
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;                        | 
        '.' DecimalNumber:FloatingPart;+ 
        (
            @'e' 
            (
                '+':Positive;               | 
                '-':Negative;
            ):Sign;Default=Positive;? 
            DecimalNumber:Value;+
        ):Exponent;? 
        (
            @'D':Double;                    | 
            @'F':Single;                    | 
            @'M':Decimal;
        ):ValueType;Default=Double;?
    )?;

Comment :=*
    SingleLineComment                       | 
    RangeComment                            ; 

#ifdef Lexer
#if Lexer == "TPPreprocessor"

Whitespace :=
    [:Zs:]                                  | 
    '\x09'                                  | 
    '\v'                                    | 
    '\t'                                    |
    '\f'                                    ; 

#elif Lexer == "TPParser"
Whitespace :=*
    (
        [:Zs:]                              | 
        '\x09'                              | 
        '\v'                                | 
        '\t'                                |
        '\f'
    )+                                      |
    NewLine; 
#endif
#endif

SingleLineComment := 
    "//" NotNewLineCharacter*;
 
RangeComment :=
    "/*" Scan("*/", true);
    
NewLine :=
    '\r'                                    | 
    '\n'                                    | 
    "\r\n"                                  | 
    '\x85'                                  | 
    '\u2028'                                | 
    '\u2029'                                ; 

NotNewLineCharacter :=
    [^\r\n\u0085\u2028\u2029];
