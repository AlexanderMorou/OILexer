#include "..\\Root.oilexer";
#include "AnonymousExpressions.oilexer";
#include "Array.oilexer";
#include "Math.oilexer";
#include "LINQ.oilexer";
#include "Templates.oilexer";
/* B.2.4: Expressions */
/* Grammar rewrite begins with expressions */
ArgumentList<Left, Right>                 ::=
    Left DelimitedList<Argument:Items;, ','>?
    Right                                   ;

Argument                                  ::=
    (
        "ref"                               | 
        "out"
    ):Direction;? ArgumentExpression:Value; ;

ArgumentExpression                       ::=>
    Expression                              |
    NamedExpression                         ;

NamedExpression                           ::=
    Identifier:ParameterName; 
    Expression:NamedExpression;             ;

ExpressionList                            ::=
    DelimitedList<Expression:Items;, ','>   ;

EnclosedExpressionList<Left, Right>       ::=
    Left ExpressionList:Items; Right        ;

PrimaryExpression                        ::=>
    ArrayCreationExpression                 |
    PrimaryNoArrayCreationExpression        ;

PrimaryNoArrayCreationExpression         ::=>
    Literal                                 |
    SimpleName                              |
    ParenthesizedExpression                 |
    MemberAccess                            |
    InvocationExpression                    |
    ElementAccess                           |
    ThisAccess                              |
    BaseAccess                              |
    PostcrementExpression                   |
    ObjectCreationExpression                |
    DelegateCreationExpression              |
    AnonymousObjectCreationExpression       |
    TypeOfExpression                        |
    CheckedExpression                       |
    UncheckedExpression                     |
    DefaultValueExpression                  |
    AnonymousMethodExpression               ;

SimpleName ::=
    Identifier:Name; TypeArgumentList:TypeParameters;?;

ParenthesizedExpression ::=
    '(' Expression:Inner; ')';

PrimaryMemberAccess                       ::=
    PrimaryExpression:PreviousAccess; '.' 
    SimpleName:CurrentAccess;               ;

PredefinedTypeMemberAccess                ::=
    (
        "bool"                              |
        "byte"                              |
        "char"                              |
        "decimal"                           |
        "double"                            |
        "float"                             |
        "int"                               |
        "long"                              |
        "object"                            |
        "sbyte"                             |
        "short"                             |
        "string"                            |
        "uint"                              |
        "ulong"                             |
        "ushort"
    ):PreviousAccess; '.' 
    SimpleName:CurrentAccess;               ;

QualifiedAliasMemberAccess                ::=
    QualifiedAliasMember:PreviousAccess; '.' 
    Identifier:CurrentAccess;               ;

MemberAccess                             ::=>
    PrimaryMemberAccess                     |
    PredefinedTypeMemberAccess              |
    QualifiedAliasMemberAccess              ;

InvocationExpression                      ::=
    PrimaryExpression:CallSite;
    ArgumentList<'(', ')'>                  ;

ElementAccess                             ::=
   PrimaryNoArrayCreationExpression:CallSite; 
   EnclosedExpressionList<'[', ']'>         ;

ThisAccess                                ::=
    "this"                                  ;

BaseAccess                               ::=>
    BaseMemberAccess                        |
    BaseElementAccess                       ;

BaseMemberAccess                          ::=
    "base" '.' Identifier:Target;           ;

BaseElementAccess                         ::=
    "base" EnclosedExpressionList<'[', ']'> ;

ObjectCreationExpression                  ::=
  "new" Type ArgumentList<'(', ')'>? 
  ObjectOrCollectionInitializer:Initializer;;

ObjectOrCollectionInitializer            ::=>
    CollectionInitializer                   |
    ObjectInitializer                       ;

ObjectInitializer                         ::=
    '{' 
        (
            DelimitedList<MemberInitializer:Members;, ','>
            ','?
        )?
    '}';

MemberInitializer                         ::=
    Identifier:Target; '=' 
    InitializerValue:Value;                 ;

InitializerValue                         ::=>
    Expression                              |
    ObjectOrCollectionInitializer           ;

CollectionInitializer                     ::=
    '{'
        (
            DelimitedList<ElementInitializer:Elements;, ','>
            ','?
        )?
    '}';

ElementInitializer                       ::=>
    NonAssignmentExpression                 |
    CurlyExpressionList                     ;
    
CurlyExpressionList                       ::=
    EnclosedExpressionList<'{', '}'>        ;

BracketExpressionList                     ::=
    EnclosedExpressionList<'[', ']'>        ;

DelegateCreationExpression                ::=
    "new" InterfaceOrDelegateType:Type;
    '(' Expression:MethodReference; ')'     ;

TypeOfExpression                          ::=
    "typeof"  '(' TypeOfType:Type; ')'      ;

TypeOfType                               ::=>
    Type                                    |
    VoidType                                |
    UnboundTypeName                         ;

UnboundTypeName                           ::=
    (Identifier:Alias; "::")? 
    DelimitedList<UnboundGenericPart:Parts;, '.'>;

UnboundGenericPart                        ::=
    Identifier:Names; 
    GenericDimensionSpecifier:Dimensions;?  ;

GenericDimensionSpecifier                 ::=
    '<' ',':Commas;* '>'                    ;

CheckedExpression                         ::=
    "checked" '(' Expression:Target; ')'    ;

UncheckedExpression                       ::=
    "unchecked" '(' Expression:Target; ')'  ;

DefaultValueExpression                    ::=
    "default" '(' Type ')'                  ;

Expression                               ::=>
    NonAssignmentExpression                 |
    AssignmentExpression                    ;

ConstantExpression                       ::=>
    Expression                              ;

BooleanExpression                        ::=>
    Expression                              ;