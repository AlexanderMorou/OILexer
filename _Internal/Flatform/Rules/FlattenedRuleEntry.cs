using System;
using System.Collections.Generic;
using System.Text;
using Oilexer.Utilities.Collections;
using System.Linq;
using Oilexer.Parser.GDFileData;
using Oilexer._Internal.Flatform.Tokens;
using Oilexer.Parser.GDFileData.ProductionRuleExpression;
using System.Collections.ObjectModel;
using Oilexer.Types;
using Oilexer.Types.Members;
using Oilexer._Internal.Flatform.Rules.StateSystem;
/* * 
 * Oilexer is an open-source project and must be released
 * as per the license associated to the project.
 * */
namespace Oilexer._Internal.Flatform.Rules
{
    /// <summary>
    /// Provides a base class for the data associated to a rule entry.
    /// </summary>
    internal class FlattenedRuleEntry :
        FlattenedRuleExpressionSeries
    {
        internal Dictionary<IProductionRuleEntry, FlattenedRuleEntry> ruleLookup;
        internal TokenFinalDataSet tokenLookup;

        public SimpleLanguageRuleState SimpleState { get { return (SimpleLanguageRuleState)base.State; } }
#if false
        /// <summary>
        /// Returns the <see cref="SyntacticalState"/> for the <see cref="FlattenedRuleEntry"/>
        /// which denotes the final form of the rule with respect to look-ahead and transitional elements.
        /// </summary>
        //public SyntacticalState FinalState { get; private set; }
#endif
        /// <summary>
        /// Returns the <see cref="IProductionRuleEntry"/> from which the
        /// <see cref="FlattenedRuleEntry"/> was derived.
        /// </summary>
        public new IProductionRuleEntry Source { get; private set; }
        /// <summary>
        /// Returns the <see cref="IInterfaceType"/>
        /// which denotes the root version of the given rule.
        /// </summary>
        public IInterfaceType RuleInterface { get; internal set; }

        /// <summary>
        /// Returns the <see cref="IMethodMember"/> on the parser
        /// class which parses the <see cref="Source"/> rule.
        /// </summary>
        public IMethodMember ParseMethod { get; internal set; }

        public FlattenedRuleEntry(IProductionRuleEntry source, Dictionary<IProductionRuleEntry, FlattenedRuleEntry> ruleLookup)
            : base(source, null, null)
        {
            this.Source = source;
            this.ruleLookup = ruleLookup;
        }

        public override void Initialize(TokenFinalDataSet tokenLookup, IProductionRuleEntry[] productionRules)
        {
            this.tokenLookup = tokenLookup;
            base.Initialize(tokenLookup, productionRules);
        }
        /*
        public void ExtractDataDependencies(IGDFile target)
        {
            if (this.DataNode == null)
                return;
            ProductionRuleEntry entry = ((ProductionRuleEntry)(this.Source));
            var dataNode = this.DataNode;
            Extract(target, entry, dataNode);
        }

        private void Extract(IGDFile target, ProductionRuleEntry entry, RuleDataGroupNode dataNode)
        {
            foreach (var dataSet in dataNode)
            {
                if (dataSet.Value.Any(p => p is RuleDataGroupNode) && dataSet.Key != RuleDataGroupNode.unnamed)
                {
                    int index = 0;
                    foreach (var group in dataSet.Value)
                    {
                        var gNode = group as RuleDataGroupNode;
                        if (gNode == null)
                            continue;
                        if (gNode.Sources.Count() > 0)
                        {
                            foreach (IProductionRuleGroupItem source in gNode.Sources)
                            {
                                IDictionary<IProductionRuleItem, IProductionRuleItem> replacementTable = new Dictionary<IProductionRuleItem, IProductionRuleItem>();
                                string name = string.Empty;

                                if (entry.IsExtract)
                                    name = string.Format("ExtractionFor{0}And{1}{2}", entry.Name.Substring(13), dataSet.Key, index == 0 ? string.Empty : index.ToString());
                                else
                                    name = string.Format("ExtractionFor{0}At{1}{2}", entry.Name, dataSet.Key, index == 0 ? string.Empty : index.ToString());
                                var resultRule = new ProductionRuleEntry(name, EntryScanMode.Inherited, "Autogenerated", 0, 0, 0);
                                /* *
                                 * This will allow the next version to properly structure its
                                 * data structures properly.
                                 * *//*

                                RuleReferenceProductionRuleItem replacement = new RuleReferenceProductionRuleItem(resultRule, 0, 0, 0);
                                foreach (var rule in source)
                                    resultRule.Add(rule);
                                replacement.Name = dataSet.Key;
                                replacement.RepeatOptions = source.RepeatOptions;
                                replacementTable.Add(source, replacement);
                                resultRule.IsExtract = true;
                                resultRule.ExtractSource = this.Source;
                                LinkerCore.ReplaceReferences(target, this.Source, replacementTable);
                                target.Add(resultRule);
                                index++;
                            }
                        }
                    }
                }
            }
        }
        //*/

        public void CondenseState()
        {
            base.State = SimpleLanguageState.Merger.ToDFA(this.SimpleState);
            this.SimpleState.Enumerate();
        }

        protected override FlattenedRuleExpression InitializeElement(IProductionRule item)
        {
            return new FlattenedRuleExpression(item, this.Source, Source, this, this);
        }

        //protected override RuleDataGroupNode InitializeDataNode()
        //{
        //    if (!this.Source.ElementsAreChildren)
        //        return base.InitializeDataNode();
        //    return null;
        //}

        protected override RuleDataSet InitializeDataSet()
        {
            if (this.Source.ElementsAreChildren)
                return null;
            return base.InitializeDataSet();
        }

        protected override SimpleLanguageState InitializeState()
        {
            return new SimpleLanguageRuleState(this);
        }

        public override string ToString()
        {
            return this.Source.Name;
        }
    }
}
