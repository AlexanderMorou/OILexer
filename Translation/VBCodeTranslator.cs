/* -------------------------------------------------------------------\
|  This code was partially generated by                               |
|  Oilexer.                                     |
|  Version: 1.0.0.0                                                   |
|---------------------------------------------------------------------|
|  The specific language is C# (Runtime version: v2.0.50727)          |
|  Sub-tool Name: Oilexer.CSharpCodeTranslator  |
|  Sub-tool Version: 1.0.0.0                                          |
\-------------------------------------------------------------------- */
using System;
using Oilexer;
using System.Collections.Generic;
using Oilexer.Properties;
using Oilexer.Types.Members;
using Oilexer.Types;
using Oilexer.Utilities.Arrays;
using System.Diagnostics;
using Oilexer._Internal;
using System.Text;
using Oilexer.Expression;
using Oilexer.Statements;
using Oilexer.Comments;
using System.Runtime.CompilerServices;
using System.CodeDom;

namespace Oilexer.Translation
{
    #region Oilexer nested types
    public partial class VBCodeTranslator :
        IntermediateCodeTranslator
    {
        /// <summary>
        /// Static lookup that is shared across all <see cref="VBCodeTranslator"/> instances
        /// for simplicity.
        /// </summary>
        /// <remarks>Elements are segmented into a length->dictionary[hashcode->value] double
        /// lookup.</remarks>
        private static Dictionary<int, Dictionary<int, string>> keywordLookup;

        static VBCodeTranslator()
        {
            keywordLookup = new Dictionary<int, Dictionary<int, string>>();
            for (int i = 2; i < 15; i++)
                InitializeLookup(i);
            InitializeLookup(16);
            /*//
            foreach (int i in new int[] { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 16 })
            {
                InitializeLookup(i);
            }
            //*/
            VBAutoFormTypeLookup = InitializeVBAutoFormTypeLookup();
        }

        #region VBCodeTranslator methods

        private static void InitializeLookup(int length)
        {
            Dictionary<int, string> result = new Dictionary<int, string>();
            switch (length)
            {
                case 2:
                    //Two letter.
                    result.Add(((int)(Keywords.As)), Resources.VBKeyWord_02_As);
                    result.Add(((int)(Keywords.Do)), Resources.VBKeyWord_02_Do);
                    result.Add(((int)(Keywords.If)), Resources.VBKeyWord_02_If);
                    result.Add(((int)(Keywords.In)), Resources.VBKeyWord_02_In);
                    result.Add(((int)(Keywords.Is)), Resources.VBKeyWord_02_Is);
                    result.Add(((int)(Keywords.Me)), Resources.VBKeyWord_02_Me);
                    result.Add(((int)(Keywords.Of)), Resources.VBKeyWord_02_Of);
                    result.Add(((int)(Keywords.On)), Resources.VBKeyWord_02_On);
                    result.Add(((int)(Keywords.Or)), Resources.VBKeyWord_02_Or);
                    result.Add(((int)(Keywords.To)), Resources.VBKeyWord_02_To);
                    break;
                case 3:
                    //Three letter.
                    result.Add(((int)(Keywords.And)), Resources.VBKeyWord_03_And);
                    result.Add(((int)(Keywords.Dim)), Resources.VBKeyWord_03_Dim);
                    result.Add(((int)(Keywords.End)), Resources.VBKeyWord_03_End);
                    result.Add(((int)(Keywords.For)), Resources.VBKeyWord_03_For);
                    result.Add(((int)(Keywords.Get)), Resources.VBKeyWord_03_Get);
                    result.Add(((int)(Keywords.Let)), Resources.VBKeyWord_03_Let);
                    result.Add(((int)(Keywords.Lib)), Resources.VBKeyWord_03_Lib);
                    result.Add(((int)(Keywords.Mod)), Resources.VBKeyWord_03_Mod);
                    result.Add(((int)(Keywords.New)), Resources.VBKeyWord_03_New);
                    result.Add(((int)(Keywords.Not)), Resources.VBKeyWord_03_Not);
                    result.Add(((int)(Keywords.Rem)), Resources.VBKeyWord_03_Rem);
                    result.Add(((int)(Keywords.Set)), Resources.VBKeyWord_03_Set);
                    result.Add(((int)(Keywords.Sub)), Resources.VBKeyWord_03_Sub);
                    result.Add(((int)(Keywords.Try)), Resources.VBKeyWord_03_Try);
                    result.Add(((int)(Keywords.XOr)), Resources.VBKeyWord_03_XOr);
                    break;
                case 4:
                    //Four letter.
                    result.Add(((int)(Keywords.Ansi)), Resources.VBKeyWord_04_Ansi);
                    result.Add(((int)(Keywords.Auto)), Resources.VBKeyWord_04_Auto);
                    result.Add(((int)(Keywords.Byte)), Resources.VBKeyWord_04_Byte);
                    result.Add(((int)(Keywords.Call)), Resources.VBKeyWord_04_Call);
                    result.Add(((int)(Keywords.Case)), Resources.VBKeyWord_04_Case);
                    result.Add(((int)(Keywords.CDbl)), Resources.VBKeyWord_04_CDbl);
                    result.Add(((int)(Keywords.CDec)), Resources.VBKeyWord_04_CDec);
                    result.Add(((int)(Keywords.Char)), Resources.VBKeyWord_04_Char);
                    result.Add(((int)(Keywords.CInt)), Resources.VBKeyWord_04_CInt);
                    result.Add(((int)(Keywords.CLng)), Resources.VBKeyWord_04_CLng);
                    result.Add(((int)(Keywords.CObj)), Resources.VBKeyWord_04_CObj);
                    result.Add(((int)(Keywords.CSng)), Resources.VBKeyWord_04_CSng);
                    result.Add(((int)(Keywords.CStr)), Resources.VBKeyWord_04_CStr);
                    result.Add(((int)(Keywords.Date)), Resources.VBKeyWord_04_Date);
                    result.Add(((int)(Keywords.Each)), Resources.VBKeyWord_04_Each);
                    result.Add(((int)(Keywords.Else)), Resources.VBKeyWord_04_Else);
                    result.Add(((int)(Keywords.Enum)), Resources.VBKeyWord_04_Enum);
                    result.Add(((int)(Keywords.Exit)), Resources.VBKeyWord_04_Exit);
                    result.Add(((int)(Keywords.GoTo)), Resources.VBKeyWord_04_GoTo);
                    result.Add(((int)(Keywords.Like)), Resources.VBKeyWord_04_Like);
                    result.Add(((int)(Keywords.Long)), Resources.VBKeyWord_04_Long);
                    result.Add(((int)(Keywords.Loop)), Resources.VBKeyWord_04_Loop);
                    result.Add(((int)(Keywords.Next)), Resources.VBKeyWord_04_Next);
                    result.Add(((int)(Keywords.Step)), Resources.VBKeyWord_04_Step);
                    result.Add(((int)(Keywords.Stop)), Resources.VBKeyWord_04_Stop);
                    result.Add(((int)(Keywords.Then)), Resources.VBKeyWord_04_Then);
                    result.Add(((int)(Keywords.True)), Resources.VBKeyWord_04_True);
                    result.Add(((int)(Keywords.Wend)), Resources.VBKeyWord_04_Wend);
                    result.Add(((int)(Keywords.When)), Resources.VBKeyWord_04_When);
                    result.Add(((int)(Keywords.With)), Resources.VBKeyWord_04_With);
                    break;
                case 5:
                    //Five letter.
                    result.Add(((int)(Keywords.Alias)), Resources.VBKeyWord_05_Alias);
                    result.Add(((int)(Keywords.ByRef)), Resources.VBKeyWord_05_ByRef);
                    result.Add(((int)(Keywords.ByVal)), Resources.VBKeyWord_05_ByVal);
                    result.Add(((int)(Keywords.Catch)), Resources.VBKeyWord_05_Catch);
                    result.Add(((int)(Keywords.CBool)), Resources.VBKeyWord_05_CBool);
                    result.Add(((int)(Keywords.CByte)), Resources.VBKeyWord_05_CByte);
                    result.Add(((int)(Keywords.CChar)), Resources.VBKeyWord_05_CChar);
                    result.Add(((int)(Keywords.CDate)), Resources.VBKeyWord_05_CDate);
                    result.Add(((int)(Keywords.Class)), Resources.VBKeyWord_05_Class);
                    result.Add(((int)(Keywords.Const)), Resources.VBKeyWord_05_Const);
                    result.Add(((int)(Keywords.CType)), Resources.VBKeyWord_05_CType);
                    result.Add(((int)(Keywords.CUInt)), Resources.VBKeyWord_05_CUInt);
                    result.Add(((int)(Keywords.CULng)), Resources.VBKeyWord_05_CULng);
                    result.Add(((int)(Keywords.EndIf)), Resources.VBKeyWord_05_EndIf);
                    result.Add(((int)(Keywords.Erase)), Resources.VBKeyWord_05_Erase);
                    result.Add(((int)(Keywords.Error)), Resources.VBKeyWord_05_Error);
                    result.Add(((int)(Keywords.Event)), Resources.VBKeyWord_05_Event);
                    result.Add(((int)(Keywords.False)), Resources.VBKeyWord_05_False);
                    result.Add(((int)(Keywords.GoSub)), Resources.VBKeyWord_05_GoSub);
                    result.Add(((int)(Keywords.IsNot)), Resources.VBKeyWord_05_IsNot);
                    result.Add(((int)(Keywords.ReDim)), Resources.VBKeyWord_05_ReDim);
                    result.Add(((int)(Keywords.SByte)), Resources.VBKeyWord_05_SByte);
                    result.Add(((int)(Keywords.Short)), Resources.VBKeyWord_05_Short);
                    result.Add(((int)(Keywords.Throw)), Resources.VBKeyWord_05_Throw);
                    result.Add(((int)(Keywords.ULong)), Resources.VBKeyWord_05_ULong);
                    result.Add(((int)(Keywords.Until)), Resources.VBKeyWord_05_Until);
                    result.Add(((int)(Keywords.Using)), Resources.VBKeyWord_05_Using);
                    result.Add(((int)(Keywords.While)), Resources.VBKeyWord_05_While);
                    break;
                case 6:
                    //Six letter.
                    result.Add(((int)(Keywords.CSByte)), Resources.VBKeyWord_06_CSByte);
                    result.Add(((int)(Keywords.CShort)), Resources.VBKeyWord_06_CShort);
                    result.Add(((int)(Keywords.Double)), Resources.VBKeyWord_06_Double);
                    result.Add(((int)(Keywords.ElseIf)), Resources.VBKeyWord_06_ElseIf);
                    result.Add(((int)(Keywords.Friend)), Resources.VBKeyWord_06_Friend);
                    result.Add(((int)(Keywords.Global)), Resources.VBKeyWord_06_Global);
                    result.Add(((int)(Keywords.Module)), Resources.VBKeyWord_06_Module);
                    result.Add(((int)(Keywords.MyBase)), Resources.VBKeyWord_06_MyBase);
                    result.Add(((int)(Keywords.Object)), Resources.VBKeyWord_06_Object);
                    result.Add(((int)(Keywords.Option)), Resources.VBKeyWord_06_Option);
                    result.Add(((int)(Keywords.OrElse)), Resources.VBKeyWord_06_OrElse);
                    result.Add(((int)(Keywords.Public)), Resources.VBKeyWord_06_Public);
                    result.Add(((int)(Keywords.Resume)), Resources.VBKeyWord_06_Resume);
                    result.Add(((int)(Keywords.Return)), Resources.VBKeyWord_06_Return);
                    result.Add(((int)(Keywords.Select)), Resources.VBKeyWord_06_Select);
                    result.Add(((int)(Keywords.Shared)), Resources.VBKeyWord_06_Shared);
                    result.Add(((int)(Keywords.Single)), Resources.VBKeyWord_06_Single);
                    result.Add(((int)(Keywords.Static)), Resources.VBKeyWord_06_Static);
                    result.Add(((int)(Keywords.String)), Resources.VBKeyWord_06_String);
                    result.Add(((int)(Keywords.TypeOf)), Resources.VBKeyWord_06_TypeOf);
                    result.Add(((int)(Keywords.UShort)), Resources.VBKeyWord_06_UShort);
                    break;
                case 7:
                    //Seven letter.
                    result.Add(((int)(Keywords.AndAlso)), Resources.VBKeyWord_07_AndAlso);
                    result.Add(((int)(Keywords.Boolean)), Resources.VBKeyWord_07_Boolean);
                    result.Add(((int)(Keywords.CUShort)), Resources.VBKeyWord_07_CUShort);
                    result.Add(((int)(Keywords.Decimal)), Resources.VBKeyWord_07_Decimal);
                    result.Add(((int)(Keywords.Declare)), Resources.VBKeyWord_07_Declare);
                    result.Add(((int)(Keywords.Default)), Resources.VBKeyWord_07_Default);
                    result.Add(((int)(Keywords.Finally)), Resources.VBKeyWord_07_Finally);
                    result.Add(((int)(Keywords.GetType)), Resources.VBKeyWord_07_GetType);
                    result.Add(((int)(Keywords.Handles)), Resources.VBKeyWord_07_Handles);
                    result.Add(((int)(Keywords.Imports)), Resources.VBKeyWord_07_Imports);
                    result.Add(((int)(Keywords.Integer)), Resources.VBKeyWord_07_Integer);
                    result.Add(((int)(Keywords.MyClass)), Resources.VBKeyWord_07_MyClass);
                    result.Add(((int)(Keywords.Nothing)), Resources.VBKeyWord_07_Nothing);
                    result.Add(((int)(Keywords.Partial)), Resources.VBKeyWord_07_Partial);
                    result.Add(((int)(Keywords.Private)), Resources.VBKeyWord_07_Private);
                    result.Add(((int)(Keywords.Shadows)), Resources.VBKeyWord_07_Shadows);
                    result.Add(((int)(Keywords.TryCast)), Resources.VBKeyWord_07_TryCast);
                    result.Add(((int)(Keywords.Unicode)), Resources.VBKeyWord_07_Unicode);
                    result.Add(((int)(Keywords.Variant)), Resources.VBKeyWord_07_Variant);
                    break;
                case 8:
                    //Eight letter.
                    result.Add(((int)(Keywords.Assembly)), Resources.VBKeyWord_08_Assembly);
                    result.Add(((int)(Keywords.Continue)), Resources.VBKeyWord_08_Continue);
                    result.Add(((int)(Keywords.Delegate)), Resources.VBKeyWord_08_Delegate);
                    result.Add(((int)(Keywords.Function)), Resources.VBKeyWord_08_Function);
                    result.Add(((int)(Keywords.Inherits)), Resources.VBKeyWord_08_Inherits);
                    result.Add(((int)(Keywords.Operator)), Resources.VBKeyWord_08_Operator);
                    result.Add(((int)(Keywords.Optional)), Resources.VBKeyWord_08_Optional);
                    result.Add(((int)(Keywords.Preserve)), Resources.VBKeyWord_08_Preserve);
                    result.Add(((int)(Keywords.Property)), Resources.VBKeyWord_08_Property);
                    result.Add(((int)(Keywords.ReadOnly)), Resources.VBKeyWord_08_ReadOnly);
                    result.Add(((int)(Keywords.SyncLock)), Resources.VBKeyWord_08_SyncLock);
                    result.Add(((int)(Keywords.UInteger)), Resources.VBKeyWord_08_UInteger);
                    result.Add(((int)(Keywords.Widening)), Resources.VBKeyWord_08_Widening);
                    break;
                case 9:
                    //Nine letter.
                    result.Add(((int)(Keywords.AddressOf)), Resources.VBKeyWord_09_AddressOf);
                    result.Add(((int)(Keywords.Interface)), Resources.VBKeyWord_09_Interface);
                    result.Add(((int)(Keywords.Namespace)), Resources.VBKeyWord_09_Namespace);
                    result.Add(((int)(Keywords.Narrowing)), Resources.VBKeyWord_09_Narrowing);
                    result.Add(((int)(Keywords.Overloads)), Resources.VBKeyWord_09_Overloads);
                    result.Add(((int)(Keywords.Overrides)), Resources.VBKeyWord_09_Overrides);
                    result.Add(((int)(Keywords.Protected)), Resources.VBKeyWord_09_Protected);
                    result.Add(((int)(Keywords.Structure)), Resources.VBKeyWord_09_Structure);
                    result.Add(((int)(Keywords.WriteOnly)), Resources.VBKeyWord_09_WriteOnly);
                    break;
                case 10:
                    //Ten letter.
                    result.Add(((int)(Keywords.AddHandler)), Resources.VBKeyWord_10_AddHandler);
                    result.Add(((int)(Keywords.DirectCast)), Resources.VBKeyWord_10_DirectCast);
                    result.Add(((int)(Keywords.Implements)), Resources.VBKeyWord_10_Implements);
                    result.Add(((int)(Keywords.ParamArray)), Resources.VBKeyWord_10_ParamArray);
                    result.Add(((int)(Keywords.RaiseEvent)), Resources.VBKeyWord_10_RaiseEvent);
                    result.Add(((int)(Keywords.WithEvents)), Resources.VBKeyWord_10_WithEvents);
                    break;
                case 11:
                    //Eleven letter.
                    result.Add(((int)(Keywords.MustInherit)), Resources.VBKeyWord_11_MustInherit);
                    result.Add(((int)(Keywords.Overridable)), Resources.VBKeyWord_11_Overridable);
                    break;
                case 13:
                    //Thirteen letter.
                    result.Add(((int)(Keywords.RemoveHandler)), Resources.VBKeyWord_13_RemoveHandler); ;
                    break;
                case 14:
                    //Fourteen letter.
                    result.Add(((int)(Keywords.Class_Finalize)), Resources.VBKeyWord_14_Class_Finalize);
                    result.Add(((int)(Keywords.NotInheritable)), Resources.VBKeyWord_14_NotInheritable);
                    result.Add(((int)(Keywords.NotOverridable)), Resources.VBKeyWord_14_NotOverridable);
                    break;
                case 16:
                    //Sixteen letter.
                    result.Add(((int)(Keywords.Class_Initialize)), Resources.VBKeyWord_16_Class_Initialize); ;
                    break;

            }
            keywordLookup.Add(length,
                result);
        }
        #endregion //VBCodeTranslator methods

        /// <summary>
        /// Translates a class-based declared type.
        /// </summary>
        /// <param name="classType">The <see cref="IClassType"/> to translate.</param>
        public override void TranslateType(IClassType classType)
        {
            //Modules can't have partials.  If they set it up assuming that, remove the 
            //functionality
            bool allowedPartials = false;
            Keywords classToken = Keywords.NoOp;
            //*
            if (_OIL._Core.DeclarationIsVBModuleCandidate(classType))
            {
                classToken = Keywords.Module;
                allowedPartials = base.Options.AllowPartials;
                base.Options.AllowPartials = false;
            }
            else
                classToken = Keywords.Class;
            //Partial (first keyword in Visual Basic)?
            this.TranslateConceptPartial(classType);
            //Only bother with this stuff if it's the root declaration.  
            //Why do needless work?
            if (classType.IsRoot)
            {
                //The attributes defined, but only on the root version, because
                //if certain attributes are redeclared, you get runtime errors 
                //(see: AttributeUsageAttribute.AllowMultiple).
                this.TranslateAttributes(classType, classType.Attributes);
                //public/private/internal/protected/protected+internal which one?
                this.TranslateConceptAccessModifiers(classType);

                //Modules don't bother with MustInherit or NotInheritable.
                //They're both (technically just NotInheritable with all static members.)
                if (classToken == Keywords.Class)
                {
                    //MustInherit?
                    this.TranslateConceptNotInstantiableClass(classType);
                    //NotInheritable?
                    this.TranslateConceptNotInheritableClass(classType);
                }
            }

            //Keyword
            TranslateConceptKeyword(classToken);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            //Name
            this.TranslateConceptIdentifier(classType);
            //Type-parameter list.
            if (classType.TypeParameters != null && classType.TypeParameters.Count > 0)
                this.TranslateTypeParameters((ITypeParameterMembers)classType.TypeParameters);
            base.WriteLine();
            base.IncreaseIndent();

            if (classType.IsRoot)
            {
                //Ensure the base type isn't System.Object, or null.
                if (classType.BaseType != null && (!(classType.BaseType.Equals(typeof(object).GetTypeReference()))))
                {
                    base.WriteLine();

                    TranslateConceptKeyword(Keywords.Inherits);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptTypeName(classType.BaseType);
                    base.WriteLine();
                }


                if (classType.ImplementsList != null && classType.ImplementsList.Count > 0)
                {
                    TranslateConceptKeyword(Keywords.Implements);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    bool firstMember = true;
                    foreach (ITypeReference itr in classType.ImplementsList)
                    {
                        if (firstMember)
                            firstMember = false;
                        else
                            base.WriteLine(", _", TranslatorFormatterTokenType.Operator);
                        TranslateConceptTypeName(itr);
                    }
                    base.WriteLine();
                }
            }
            int memberCount = 0, typeCount = 0;
            if (base.Options.AllowPartials)
            {
                memberCount = classType.GetMemberCount(false);
                typeCount = classType.GetTypeCount(false);
            }
            else
            {
                memberCount = classType.GetMemberCount(true);
                typeCount = classType.GetTypeCount(true);
            }

            this.TranslateMemberParentTypeMembers(classType);
            //Space the members from the types.
            if (memberCount > 0 && typeCount > 0)
                base.WriteLine();
            //Nested types.
            if (!(classType is IDeclarationResources))
                this.TranslateTypeParentTypes(classType);
            base.DecreaseIndent();

            this.TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(classToken);
            if (classToken == Keywords.Module)
            {
                base.Options.AllowPartials = allowedPartials;
            }
            base.WriteLine();
        }

        /// <summary>
        /// Translates an enumerator-based declared type.
        /// </summary>
        /// <param name="enumeratorType">The <see cref="IEnumeratorType"/> to translate.</param>
        public override void TranslateType(IEnumeratorType enumeratorType)
        {
            TranslateAttributes(enumeratorType, enumeratorType.Attributes);
            TranslateConceptAccessModifiers(enumeratorType);
            TranslateConceptKeyword(Keywords.Enum);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(enumeratorType);
            switch (enumeratorType.BaseType)
            {
                case EnumeratorBaseType.UByte:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.Byte);
                    break;
                case EnumeratorBaseType.SByte:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.SByte);
                    break;
                case EnumeratorBaseType.UShort:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.UShort);
                    break;
                case EnumeratorBaseType.Short:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.Short);
                    break;
                case EnumeratorBaseType.UInt:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.UInteger);
                    break;
                case EnumeratorBaseType.ULong:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.ULong);
                    break;
                case EnumeratorBaseType.SLong:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    this.TranslateConceptKeyword(Keywords.Long);
                    break;
                case EnumeratorBaseType.SInt:
                default:
                    break;
            }
            base.WriteLine();
            base.IncreaseIndent();
            TranslateMembers(enumeratorType, enumeratorType.Fields);
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Enum);
            base.WriteLine();
        }

        public override void TranslateMembers(IEnumeratorType parent, IEnumTypeFieldMembers fieldMembers)
        {
            bool flag = true;
            foreach (IFieldMember ifm in fieldMembers.Values)
            {
                if (flag)
                    flag = false;
                else
                {
                    base.WriteLine();
                    base.WriteLine();
                }
                if (base.Options.AutoComments)
                {
                    if (ifm.Summary != null && ifm.Summary != string.Empty)
                        TranslateConceptComment(GetSummaryDocumentComment(ifm.Summary), true);
                    if (ifm.Remarks != null && ifm.Remarks != string.Empty)
                        TranslateConceptComment(GetRemarksDocumentComment(ifm.Remarks), true);
                }
                this.TranslateAttributes(ifm, ifm.Attributes);
                this.TranslateConceptIdentifier(ifm);
                if (ifm.InitializationExpression != null)
                {
                    base.Write(" = ", TranslatorFormatterTokenType.Operator);
                    this.TranslateExpression(ifm.InitializationExpression);
                }
            }
            base.WriteLine();
        }

        /// <summary>
        /// Translates a delegate-based declared type.
        /// </summary>
        /// <param name="delegateType">The <see cref="IDelegateType"/> to translate.</param>
        public override void TranslateType(IDelegateType delegateType)
        {
            Keywords delegateMethType = Keywords.NoOp;
            TranslateConceptAccessModifiers(delegateType);
            TranslateConceptKeyword(Keywords.Delegate);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            if (delegateType.ReturnType == null || delegateType.ReturnType.Equals(typeof(void).GetTypeReference()))
                delegateMethType = Keywords.Sub;
            else
                delegateMethType = Keywords.Function;
            TranslateConceptKeyword(delegateMethType);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(delegateType);
            if (delegateType.TypeParameters != null && delegateType.TypeParameters.Count > 0)
                TranslateTypeParameters((ITypeParameterMembers)delegateType.TypeParameters);
            if (delegateType.Parameters != null)
                TranslateParameters(delegateType.Parameters);
            if (delegateMethType == Keywords.Function)
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.As);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptTypeName(delegateType.ReturnType);
            }
            base.WriteLine();
        }

        /// <summary>
        /// Translates an interface-based declared type.
        /// </summary>
        /// <param name="interfaceType">The <see cref="IInterfaceType"/> to translate.</param>
        public override void TranslateType(IInterfaceType interfaceType)
        {
            TranslateAttributes(interfaceType, interfaceType.Attributes);
            TranslateConceptAccessModifiers(interfaceType);
            TranslateConceptPartial(interfaceType);
            TranslateConceptKeyword(Keywords.Interface);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(interfaceType);
            if (interfaceType.TypeParameters != null && interfaceType.TypeParameters.Count > 0)
                TranslateTypeParameters((ITypeParameterMembers)interfaceType.TypeParameters);
            base.WriteLine();
            base.IncreaseIndent();
            TranslateSignatureMemberParentTypeMembers(interfaceType);
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Interface);
            base.WriteLine();
        }

        /// <summary>
        /// Translates a structure-based declared type.
        /// </summary>
        /// <param name="structureType">The <see cref="IStructType"/> to translate.</param>
        public override void TranslateType(IStructType structureType)
        {
            TranslateAttributes(structureType, structureType.Attributes);
            TranslateConceptPartial(structureType);
            TranslateConceptAccessModifiers(structureType);
            TranslateConceptKeyword(Keywords.Structure);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(structureType);

            if (structureType.TypeParameters.Count > 0)
                this.TranslateTypeParameters((ITypeParameterMembers)structureType.TypeParameters);
            base.WriteLine();
            base.IncreaseIndent();

            if (structureType.ImplementsList != null && structureType.ImplementsList.Count > 0)
            {
                TranslateConceptKeyword(Keywords.Implements);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                bool firstMember = true;
                foreach (ITypeReference itr in structureType.ImplementsList)
                {
                    if (firstMember)
                        firstMember = false;
                    else
                        base.WriteLine(", _", TranslatorFormatterTokenType.Operator);
                    TranslateConceptTypeName(itr);
                }
                base.WriteLine();
            }
            int memberCount = 0, typeCount = 0;
            if (base.Options.AllowPartials)
            {
                memberCount = structureType.GetMemberCount(false);
                typeCount = structureType.GetTypeCount(false);
            }
            else
            {
                memberCount = structureType.GetMemberCount(true);
                typeCount = structureType.GetTypeCount(true);
            }

            this.TranslateMemberParentTypeMembers(structureType);
            //Space the members from the types.
            if (memberCount > 0 && typeCount > 0)
                base.WriteLine();
            //Nested types.
            this.TranslateTypeParentTypes(structureType);
            base.DecreaseIndent();

            this.TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.Structure);
            base.WriteLine();

        }

        /// <summary>
        /// Translates an <see cref="IIntermediateProject"/> as a whole or 
        /// partial by partial.
        /// </summary>
        /// <param name="project">The <see cref="IIntermediateProject"/> to translate.</param>
        /// <remarks>Depending on the <see cref="Options"/>, this will translate all declared namespaces 
        /// or just those on the current partial.</remarks>
        public override void TranslateProject(IIntermediateProject project)
        {
            if (((!(base.Options.AllowPartials)) && (project.IsPartial)))
                return;
            base.Options.BuildTrail.Push(project);
            Stopwatch sw = new Stopwatch();
            StringBuilder typesUsed;
            sw.Start();
            this.TranslateConceptComment(this.GeneratedMessageText, false);
            if (base.Options.AutoResolveReferences)
            {
                ProjectDependencyReport pdr = new ProjectDependencyReport(project, base.Options);
                pdr.Reduce();
                foreach (string s in pdr.NameSpaceDependencies)
                    Options.ImportList.Add(s);
                typesUsed = _OIL._Core.GetTypesUsedComment(ref pdr, base.Options);
            }
            else
                typesUsed = null;
            if (Options.ImportList.Count > 0)
            {

                foreach (string s in Options.ImportList)
                {
                    this.TranslateConceptKeyword(Keywords.Imports);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    base.WriteLine(s, TranslatorFormatterTokenType.NameSpace);
                }
                base.WriteLine();
            }
            Options.ImportList.Clear();
            this.TranslateNameSpaces(project, project.NameSpaces);
            if ((project.GetTypeCount(!base.Options.AllowPartials) > 0) && (project.GetNameSpaceCount(!base.Options.AllowPartials) > 0))
                base.Target.WriteLine();
            TranslateTypeParentTypes(project);
            //foreach (ITypeReference itr in pdr
            sw.Stop();
            string typesUsedExp;
            if (typesUsed == null)
                typesUsedExp = "";
            else
                typesUsedExp = string.Format("\r\n{0}", typesUsed.ToString());
            this.TranslateConceptComment(string.Format("This file took {0} to generate.\r\nDate generated: {1}{2}", sw.Elapsed, DateTime.Now, typesUsedExp), false);
            base.Options.BuildTrail.Pop();
        }

        /// <summary>
        /// Translates a namespace declaration.
        /// </summary>
        /// <param name="nameSpace">The <see cref="INameSpaceDeclaration"/> to translate.</param>
        /// <remarks>Depending on the <see cref="Options"/>, this will translate all of the declared 
        /// child namespaces and the current <see cref="INameSpaceDeclaration"/>'s types or just 
        /// those on the current partial.</remarks>
        public override void TranslateNameSpace(INameSpaceDeclaration nameSpace)
        {
            if (!(nameSpace.GetNameSpaceCount(!(Options.AllowPartials)) > 0 || nameSpace.GetTypeCount(!base.Options.AllowPartials) > 0))
                return;
            base.Options.BuildTrail.Push(nameSpace);
            TranslateConceptKeyword(Keywords.Namespace);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(nameSpace);
            base.WriteLine();
            base.IncreaseIndent();
            /*
            if (nameSpace.Project != null && nameSpace.Project.DefaultNameSpace.GetRootDeclaration() == nameSpace.GetRootDeclaration())
            {
                if (nameSpace.Project.Resources.GetMemberCount(false) > 0)
                {
                    base.Options.BuildTrail.Push(nameSpace.Project.Resources.GetRootDeclaration());
                    TranslateType(nameSpace.Project.Resources);
                    base.Options.BuildTrail.Pop();
                }
            }
            //*/
            this.TranslateTypeParentTypes(nameSpace);
            this.TranslateNameSpaces(nameSpace, nameSpace.ChildSpaces);
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Namespace);
            base.WriteLine();
            base.Options.BuildTrail.Pop();
        }

        public override void TranslateMember<TParameter, TTypeParameter, TSignatureDom, TParent>(IMethodSignatureMember<TParameter, TTypeParameter, TSignatureDom, TParent> ambigMethodSigMember)
        {
            Keywords methodType = Keywords.NoOp;
            if (ambigMethodSigMember.ReturnType.Equals(typeof(void).GetTypeReference()))
                methodType = Keywords.Sub;
            else
                methodType = Keywords.Function;
            TranslateAttributes(ambigMethodSigMember, ambigMethodSigMember.Attributes);
            if (ambigMethodSigMember is IMethodMember)
            {
                TranslateConceptAccessModifiers(ambigMethodSigMember);
                if (((IMethodMember)(ambigMethodSigMember)).IsStatic)
                {
                    if ((!(_OIL._Core.DeclarationIsVBModule(ambigMethodSigMember.ParentTarget, base.Options))))
                    {
                        TranslateConceptKeyword(Keywords.Shared);
                        base.Write(" ", TranslatorFormatterTokenType.Other);
                    }
                }
            }
            TranslateConceptKeyword(methodType);
            Target.Write(" ");
            if (ambigMethodSigMember is IImplementedMember)
                TranslateConceptPrivateImplementationTarget((IImplementedMember)ambigMethodSigMember);
            else
                TranslateConceptIdentifier(ambigMethodSigMember);
            if (ambigMethodSigMember.TypeParameters != null && ambigMethodSigMember.TypeParameters.Count > 0)
                TranslateTypeParameters((ITypeParameterMembers)ambigMethodSigMember.TypeParameters);
            if (ambigMethodSigMember.Parameters != null)
                TranslateParameters(ambigMethodSigMember.Parameters);

            if (methodType != Keywords.Sub)
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.As);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptTypeName(ambigMethodSigMember.ReturnType);
            }

            if (!(ambigMethodSigMember is IMethodMember))
            {
                base.WriteLine();
                return;
            }
            IMethodMember methodSpecific = (IMethodMember)ambigMethodSigMember;
            base.IncreaseIndent();
            if (methodSpecific.PrivateImplementationTarget != null)
            {
                base.WriteLine(" _", TranslatorFormatterTokenType.Operator);
                TranslateConceptKeyword(Keywords.Implements);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptTypeName(methodSpecific.PrivateImplementationTarget);
                base.Write(".", TranslatorFormatterTokenType.Operator);
                TranslateConceptIdentifier(methodSpecific);
                base.WriteLine();
            }
            base.WriteLine();
            TranslateStatementBlock(methodSpecific.Statements);
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(methodType);
            base.WriteLine();
        }

        private void TranslateConceptPrivateImplementationTarget(IImplementedMember iImplementedMember)
        {
            if (iImplementedMember.PrivateImplementationTarget != null)
            {
                bool autoRes = base.Options.AutoResolveReferences;
                base.Options.AutoResolveReferences = false;
                string methodName = GetConceptIdentifier(iImplementedMember);
                string typeName = GetTypeName(iImplementedMember.PrivateImplementationTarget);
                base.Write(string.Format("{0}.{1}", typeName, GetConceptIdentifier(iImplementedMember)).Replace('.', '_'), TranslatorFormatterTokenType.Preformatted);
                if (autoRes)
                    base.Options.AutoResolveReferences = autoRes;
            }
            else
                TranslateConceptIdentifier(iImplementedMember);
        }

        public override void TranslateMember(IIndexerSignatureMember indexerSigMember)
        {
            Keywords rwOp = Keywords.NoOp;
            if ((!(indexerSigMember.HasGet)) && (indexerSigMember.HasSet))
                rwOp = Keywords.WriteOnly;
            else if (indexerSigMember.HasGet && (!(indexerSigMember.HasSet)))
                rwOp = Keywords.ReadOnly;
            TranslateAttributes(indexerSigMember, indexerSigMember.Attributes);
            if (rwOp != Keywords.NoOp)
            {
                TranslateConceptKeyword(rwOp);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            TranslateConceptKeyword(Keywords.Property);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(indexerSigMember);
            TranslateParameters(indexerSigMember.Parameters);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(indexerSigMember.PropertyType);
            base.WriteLine();
        }

        public override void TranslateMember(IIndexerMember indexerMember)
        {
            Keywords rwOp = Keywords.NoOp;
            if ((!(indexerMember.HasGet)) && (indexerMember.HasSet))
                rwOp = Keywords.WriteOnly;
            else if (indexerMember.HasGet && (!(indexerMember.HasSet)))
                rwOp = Keywords.ReadOnly;
            TranslateAttributes(indexerMember, indexerMember.Attributes);
            TranslateConceptAccessModifiers(indexerMember);
            if (((IPropertyMember)(indexerMember)).IsStatic)
            {
                if ((!(_OIL._Core.DeclarationIsVBModule(indexerMember.ParentTarget, base.Options))))
                {
                    TranslateConceptKeyword(Keywords.Shared);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                }
            }
            if (rwOp != Keywords.NoOp)
            {
                TranslateConceptKeyword(rwOp);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            TranslateConceptKeyword(Keywords.Property);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptPrivateImplementationTarget(indexerMember);
            TranslateParameters(indexerMember.Parameters);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(indexerMember.PropertyType);
            if (!indexerMember.IsAbstract)
            {
                base.IncreaseIndent();
                if (indexerMember.PrivateImplementationTarget != null)
                {
                    base.WriteLine(" _", TranslatorFormatterTokenType.Operator);
                    TranslateConceptKeyword(Keywords.Implements);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptTypeName(indexerMember.PrivateImplementationTarget);
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                    TranslateConceptIdentifier(indexerMember);
                }
                base.WriteLine();
                if (indexerMember.HasGet)
                {
                    TranslateConceptKeyword(Keywords.Get);
                    base.WriteLine();
                    base.IncreaseIndent();
                    TranslateStatementBlock(indexerMember.GetPart.Statements);
                    base.DecreaseIndent();
                    TranslateConceptKeyword(Keywords.End);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Get);
                    base.WriteLine();
                }
                if (indexerMember.HasSet)
                {
                    TranslateConceptKeyword(Keywords.Set);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    TranslateConceptKeyword(Keywords.ByVal);
                    base.Write(" value ", TranslatorFormatterTokenType.Keyword);
                    TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptTypeName(indexerMember.PropertyType);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    base.WriteLine();
                    base.IncreaseIndent();
                    TranslateStatementBlock(indexerMember.SetPart.Statements);
                    base.DecreaseIndent();
                    TranslateConceptKeyword(Keywords.End);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Set);
                    base.WriteLine();
                }
                base.DecreaseIndent();
                TranslateConceptKeyword(Keywords.End);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.Property);
                base.WriteLine();
            }
            else
            {
                base.WriteLine();
                return;
            }
        }

        public override void TranslateMember<TParent>(IPropertySignatureMember<TParent> ambigPropertySigMember)
        {
            Keywords rwOp = Keywords.NoOp;
            if ((!(ambigPropertySigMember.HasGet)) && (ambigPropertySigMember.HasSet))
                rwOp = Keywords.WriteOnly;
            else if (ambigPropertySigMember.HasGet && (!(ambigPropertySigMember.HasSet)))
                rwOp = Keywords.ReadOnly;
            TranslateAttributes(ambigPropertySigMember, ambigPropertySigMember.Attributes);
            if (ambigPropertySigMember is IPropertyMember)
            {
                TranslateConceptAccessModifiers(ambigPropertySigMember);
                if (((IPropertyMember)(ambigPropertySigMember)).IsStatic)
                {
                    if ((!(_OIL._Core.DeclarationIsVBModule(ambigPropertySigMember.ParentTarget, base.Options))))
                    {
                        TranslateConceptKeyword(Keywords.Shared);
                        base.Write(" ", TranslatorFormatterTokenType.Other);
                    }
                }
            }
            if (rwOp != Keywords.NoOp)
            {
                TranslateConceptKeyword(rwOp);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            TranslateConceptKeyword(Keywords.Property);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            if (ambigPropertySigMember is IImplementedMember)
            {
                TranslateConceptPrivateImplementationTarget((IImplementedMember)ambigPropertySigMember);
            }
            else
                TranslateConceptIdentifier(ambigPropertySigMember);
            base.Write("() ", TranslatorFormatterTokenType.Operator);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(ambigPropertySigMember.PropertyType);
            if (ambigPropertySigMember is IPropertyMember && (!((IPropertyMember)(ambigPropertySigMember)).IsAbstract))
            {
                base.IncreaseIndent();
                IPropertyMember ipm = ((IPropertyMember)(ambigPropertySigMember));
                if (ipm.PrivateImplementationTarget != null)
                {
                    base.WriteLine(" _", TranslatorFormatterTokenType.Operator);
                    TranslateConceptKeyword(Keywords.Implements);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptTypeName(ipm.PrivateImplementationTarget);
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                    TranslateConceptIdentifier(ambigPropertySigMember);
                }
                base.WriteLine();
                if (ipm.HasGet)
                {
                    TranslateConceptKeyword(Keywords.Get);
                    base.WriteLine();
                    base.IncreaseIndent();
                    TranslateStatementBlock(ipm.GetPart.Statements);
                    base.DecreaseIndent();
                    TranslateConceptKeyword(Keywords.End);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Get);
                    base.WriteLine();
                }
                if (ipm.HasSet)
                {
                    TranslateConceptKeyword(Keywords.Set);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    TranslateConceptKeyword(Keywords.ByVal);
                    base.Write(" value ", TranslatorFormatterTokenType.Keyword);
                    TranslateConceptKeyword(Keywords.As);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptTypeName(ipm.PropertyType);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    base.WriteLine();
                    base.IncreaseIndent();
                    TranslateStatementBlock(ipm.SetPart.Statements);
                    base.DecreaseIndent();
                    TranslateConceptKeyword(Keywords.End);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Set);
                    base.WriteLine();
                }
                base.DecreaseIndent();
                TranslateConceptKeyword(Keywords.End);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.Property);
                base.WriteLine();
            }
            else
            {
                base.WriteLine();
                return;
            }
        }

        public override void TranslateMember(IFieldMember fieldMember)
        {
            if (base.Options.AutoComments)
            {
                if (fieldMember.Summary != null && fieldMember.Summary != string.Empty)
                    TranslateConceptComment(GetSummaryDocumentComment(fieldMember.Summary), true);
                if (fieldMember.Remarks != null && fieldMember.Remarks != string.Empty)
                    TranslateConceptComment(GetRemarksDocumentComment(fieldMember.Remarks), true);
            }
            this.TranslateAttributes(fieldMember, fieldMember.Attributes);
            this.TranslateConceptAccessModifiers(fieldMember);
            //If it's a static member, not part of a module,
            //Denote it's shared.
            if (fieldMember.IsStatic && (!(_OIL._Core.DeclarationIsVBModule(fieldMember.ParentTarget, base.Options))))
            {
                TranslateConceptKeyword(Keywords.Shared);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            this.TranslateConceptIdentifier(fieldMember);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptTypeName(fieldMember.FieldType);
            if (fieldMember.InitializationExpression != null)
            {
                base.Write(" = ", TranslatorFormatterTokenType.Operator);
                this.TranslateExpression(fieldMember.InitializationExpression);
            }
            base.WriteLine();
        }

        public override void TranslateMember(IConstructorMember constructorMember)
        {
            this.TranslateAttributes(constructorMember, constructorMember.Attributes);
            if (constructorMember.IsStatic)
            {
                this.TranslateConceptKeyword(Keywords.Shared);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            else
                this.TranslateConceptAccessModifiers(constructorMember);
            this.TranslateConceptKeyword(Keywords.Sub);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.New);
            this.TranslateParameters(constructorMember.Parameters);
            base.WriteLine();
            base.IncreaseIndent();
            if (constructorMember.CascadeExpressionsTarget != ConstructorCascadeTarget.Undefined)
            {
                switch (constructorMember.CascadeExpressionsTarget)
                {
                    case ConstructorCascadeTarget.Base:
                        TranslateConceptKeyword(Keywords.MyBase);
                        break;
                    case ConstructorCascadeTarget.This:
                        TranslateConceptKeyword(Keywords.Me);
                        break;
                }
                base.Write(".", TranslatorFormatterTokenType.Operator);
                this.TranslateConceptKeyword(Keywords.New);
                base.Write("(", TranslatorFormatterTokenType.Operator);
                this.TranslateExpressionGroup(constructorMember.CascadeMembers);
                base.Write(")", TranslatorFormatterTokenType.Operator);
                this.TranslateConceptComment("Cascade constructor.", false);
                base.WriteLine();
            }
            this.TranslateStatementBlock(constructorMember.Statements);
            base.DecreaseIndent();
            this.TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.Sub);
            base.WriteLine();
        }

        public override void TranslateMember<TParameter, TParameteredDom, TParent>(IParameteredParameterMember<TParameter, TParameteredDom, TParent> ambigParamMember)
        {
            switch (ambigParamMember.Direction)
            {
                case System.CodeDom.FieldDirection.Out:
                case System.CodeDom.FieldDirection.Ref:
                    TranslateConceptKeyword(Keywords.ByRef);
                    break;
                default:
                    TranslateConceptKeyword(Keywords.ByVal);
                    break;
            }
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(ambigParamMember);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(ambigParamMember.ParameterType);
        }

        public override void TranslateMember<TDom, TParent>(ITypeParameterMember<TDom, TParent> typeParamMember)
        {
            this.TranslateConceptIdentifier(typeParamMember);
        }

        public override void TranslateStatement(IAssignStatement assignStatement)
        {
            this.TranslateExpression(assignStatement.Reference);
            base.Write(" = ", TranslatorFormatterTokenType.Operator);
            this.TranslateExpression(assignStatement.Value);
            base.WriteLine();
        }

        public override void TranslateStatement(IBreakTargetExitPoint breakTarget)
        {
        }

        public override void TranslateStatement(IBreakStatement breakStatement)
        {
            IStatement s = breakStatement;
            while (!((s == null) || (s is IBreakTargetStatement)))
            {
                if (s.SourceBlock.Parent is IBlockedStatement)
                    s = (IBlockedStatement)s.SourceBlock.Parent;
            }
            //If the base.Target wasn't a blocked statement...
            if (s == null)
            {
                s = breakStatement;
                Keywords memberType = Keywords.NoOp;
                //Do another scan for a top level member...
                while (s != null)
                {
                    if (s.SourceBlock.Parent is IStatement)
                        s = (IBlockedStatement)s.SourceBlock.Parent;
                    else if (s.SourceBlock.Parent is IMethodMember)
                    {
                        IMethodMember imm = (IMethodMember)s.SourceBlock.Parent;
                        if (imm.ReturnType.Equals(typeof(void).GetTypeReference()))
                        {
                            memberType = Keywords.Sub;
                        }
                        else
                            memberType = Keywords.Function;
                        break;
                    }
                    else if (s.SourceBlock.Parent is IPropertyBodyMember)
                        memberType = Keywords.Property;
                    else if (s.SourceBlock.Parent is IConstructorMember)
                        memberType = Keywords.Sub;
                }
                if (memberType == Keywords.NoOp)
                    TranslateConceptComment("Invalid Breakpoint", false);
                else
                {
                    TranslateConceptKeyword(Keywords.Exit);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(memberType);
                    base.WriteLine();
                }
            }
            else if (s is IForRangeStatement || s is IEnumeratorStatement)
            {
                TranslateConceptKeyword(Keywords.Exit);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.For);
                base.WriteLine();
            }
            else if (s is ISwitchStatement)
            {
                TranslateConceptKeyword(Keywords.Exit);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.Select);
                base.WriteLine();
            }

        }

        public override void TranslateStatement(ICommentStatement commentStatement)
        {
            TranslateConceptComment(commentStatement.Comment, false);
        }

        public override void TranslateStatement(IConditionStatement ifThenStatement)
        {
            this.TranslateConceptKeyword(Keywords.If);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateExpression(ifThenStatement.Condition);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.Then);
            base.WriteLine();
            base.IncreaseIndent();
            TranslateStatementBlock(ifThenStatement.Statements);
            base.DecreaseIndent();
            this.TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptKeyword(Keywords.If);
            base.WriteLine();
        }

        public override void TranslateStatement(ISwitchStatement switchStatement)
        {
            TranslateConceptKeyword(Keywords.Select);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Case);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateExpression(switchStatement.CaseSwitch);
            base.WriteLine();
            base.IncreaseIndent();
            foreach (ISwitchStatementCase @case in switchStatement.Cases)
            {
                if (@case.Cases.Count > 0)
                {
                    TranslateConceptKeyword(Keywords.Case);
                    bool first = true;
                    foreach (IExpression expr in @case.Cases)
                    {
                        if (first)
                            first = false;
                        else
                            base.Write(",", TranslatorFormatterTokenType.Operator);
                        base.Write(" ", TranslatorFormatterTokenType.Other);
                        TranslateExpression(expr);
                    }
                    base.WriteLine();
                    base.IncreaseIndent();
                    base.TranslateStatementBlock(@case.Statements);
                }
                if (@case.LastIsDefaultCase)
                {
                    if (@case.Cases.Count > 0)
                        base.DecreaseIndent();
                    TranslateConceptKeyword(Keywords.Case);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Else);
                    base.WriteLine();
                    base.IncreaseIndent();
                    base.TranslateStatementBlock(@case.Statements);
                }
                base.DecreaseIndent();
            }
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.End);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Select);
            base.WriteLine();
        }

        public override void TranslateStatement(IEnumeratorStatement enumStatement)
        {
            TranslateConceptKeyword(Keywords.For);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.Each);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(enumStatement.CurrentMember);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(enumStatement.CurrentMember.LocalType);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.In);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateExpression(enumStatement.EnumeratorSource);
            base.WriteLine();
            base.IncreaseIndent();
            TranslateStatementBlock(enumStatement.Statements);
            base.DecreaseIndent();
            TranslateConceptKeyword(Keywords.Next);
            base.WriteLine();
        }

        public override void TranslateStatement(IForRangeStatement forRangeStatement)
        {
            TranslateConceptKeyword(Keywords.For);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptIdentifier(forRangeStatement.IterationIndex);
            //Check to see if the local is defined by the for statement, if it is, then
            //declare it as part of the loop
            if (forRangeStatement.Locals.ContainsKey(forRangeStatement.IterationIndex.Name))
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.As);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptTypeName(forRangeStatement.IterationIndex.LocalType);
            }
            base.Write(" = ", TranslatorFormatterTokenType.Operator);
            TranslateExpression(forRangeStatement.Start);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.To);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateExpression(forRangeStatement.Max);
            if (forRangeStatement.Step != null && (!(forRangeStatement.Step is IPrimitiveExpression && ((IPrimitiveExpression)(forRangeStatement.Step)).TypeCode == TypeCode.Int32 && ((int)(((IPrimitiveExpression)(forRangeStatement.Step)).Value)) == 1)))
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.Step);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateExpression(forRangeStatement.Step);
            }
        }

        public override void TranslateStatement(IGoToLabelStatement gotoLabelStatement)
        {
            TranslateConceptKeyword(Keywords.GoTo);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            base.WriteLine(gotoLabelStatement.LabelStatement.Name, TranslatorFormatterTokenType.Other);
        }

        public override void TranslateStatement(IIterationStatement iterationStatement)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void TranslateStatement(ILabelStatement labelStatement)
        {
            int indent = base.Target.Indent;
            base.Target.Indent = 0;
            TranslateConceptIdentifier(labelStatement.Name);
            base.WriteLine(":", TranslatorFormatterTokenType.Operator);
            base.Target.Indent = indent;
        }

        public override void TranslateStatement(ILocalDeclarationStatement localDeclare)
        {
            IStatementBlockLocalMember isblm = localDeclare.ReferencedMember;
            TranslateConceptKeyword(Keywords.Dim);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptIdentifier(isblm);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptKeyword(Keywords.As);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptTypeName(isblm.LocalType);
            if (isblm.InitializationExpression != null)
            {
                base.Write(" = ", TranslatorFormatterTokenType.Operator);
                this.TranslateExpression(isblm.InitializationExpression);
            }
            base.WriteLine();
        }

        public override void TranslateStatement(IReturnStatement returnStatement)
        {
            TranslateConceptKeyword(Keywords.Return);
            if (returnStatement.Result != null)
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                this.TranslateExpression(returnStatement.Result);
            }
            base.WriteLine();
        }

        public override void TranslateStatement(ISimpleStatement callMethodStatement)
        {
            this.TranslateExpression(callMethodStatement.Expression);
            base.WriteLine();
        }

        public override void TranslateConceptPartial(ISegmentableDeclarationTarget seggedDecl)
        {
            if ((!(base.Options.AllowPartials)) || ((seggedDecl is IClassType) && ((IClassType)(seggedDecl)).IsStatic))
                return;
            if ((seggedDecl.IsPartial) || ((seggedDecl.IsRoot) && (seggedDecl.Partials.Count > 0)))
            {
                TranslateConceptKeyword(Keywords.Partial);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
        }

        public override void TranslateConceptAccessModifiers(IDeclaration decl)
        {
            if (decl.ParentTarget is ISignatureMemberParentType)
                return;
            //Pretty basic, if the base.base.Target is a namespace translate family accessors 
            //to assembly, and non-public accessors to assembly.
            switch (decl.AccessLevel)
            {
                case DeclarationAccessLevel.Public:
                    TranslateConceptKeyword(Keywords.Public);
                    break;
                case DeclarationAccessLevel.Private:
                    if (decl.ParentTarget is INameSpaceDeclaration || decl.ParentTarget is IIntermediateProject)
                        TranslateConceptKeyword(Keywords.Friend);
                    else
                        TranslateConceptKeyword(Keywords.Private);
                    break;
                case DeclarationAccessLevel.Internal:
                    TranslateConceptKeyword(Keywords.Friend);
                    break;
                case DeclarationAccessLevel.Protected:
                    if (decl.ParentTarget is INameSpaceDeclaration || decl.ParentTarget is IIntermediateProject)
                    {
                        TranslateConceptKeyword(Keywords.Friend);
                    }
                    else
                    {
                        TranslateConceptKeyword(Keywords.Protected);
                    }
                    break;
                case DeclarationAccessLevel.ProtectedInternal:
                    if (decl.ParentTarget is INameSpaceDeclaration || decl.ParentTarget is IIntermediateProject)
                        TranslateConceptKeyword(Keywords.Friend);
                    else
                    {
                        TranslateConceptKeyword(Keywords.Protected);
                        base.Write(" ", TranslatorFormatterTokenType.Other);
                        TranslateConceptKeyword(Keywords.Friend);
                    }
                    break;
                default:
                    if (decl.ParentTarget is INameSpaceDeclaration || decl.ParentTarget is IIntermediateProject)
                        TranslateConceptKeyword(Keywords.Friend);
                    else
                        TranslateConceptKeyword(Keywords.Private);
                    break;
            }
            base.Write(" ", TranslatorFormatterTokenType.Other);
        }

        /// <summary>
        /// Translates the 'NotInstantiable'/'abstract' concept.
        /// </summary>
        /// <param name="classType">The <see cref="IClassType"/> that is NotInstanciable</param>
        public override void TranslateConceptNotInstantiableClass(IClassType classType)
        {
            if (classType.IsAbstract)
            {
                TranslateConceptKeyword(Keywords.MustInherit);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
        }

        /// <summary>
        /// Translates the 'NotInheritable'/'sealed' concept.
        /// </summary>
        /// <param name="classType">The <see cref="IClassType"/> which is not inheritable.</param>
        public override void TranslateConceptNotInheritableClass(IClassType classType)
        {
            if (classType.IsSealed)
            {
                TranslateConceptKeyword(Keywords.NotInheritable);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            else 
                TranslateConceptNotInheritableOrInstantiableClass(classType);
        }

        /// <summary>
        /// Translates the [NotInheritable/Module]/static concept
        /// </summary>
        /// <param name="classType"><para>The <see cref="IClassType"/> that, if top-level and not segmented across multiple files, is a VB Module.</para></param>
        public override void TranslateConceptNotInheritableOrInstantiableClass(IClassType classType)
        {
            if (!_OIL._Core.DeclarationIsVBModule(classType, base.Options) && classType.IsStatic)
            {
                TranslateConceptKeyword(Keywords.NotInheritable);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
        }

        public override string EscapeString(string value, int indentLevel)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(@"""");
            foreach (char c in value)
                if (c == '"')
                    sb.Append(@"""""");
                else
                    sb.Append(c);
            sb.Append(@"""");
            return sb.ToString();
        }

        public override sealed bool IsKeyword(string identifier)
        {
            int length = identifier.Length;
            if (!keywordLookup.ContainsKey(identifier.Length))
                return false;
            return keywordLookup[length].ContainsKey(identifier.ToLower().GetHashCode());
        }

        public override string EscapeIdentifier(string identifier)
        {
            return string.Format("[{0}]", identifier);
        }

        public override void TranslateTypeParameters(ITypeParameterMembers typeParameterMembers)
        {
            if ((!((typeParameterMembers != null) && (typeParameterMembers.Count > 0))))
                return;
            base.IncreaseIndent();
            base.Write("(", TranslatorFormatterTokenType.Operator);
            TranslateConceptKeyword(Keywords.Of);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            bool firstMember = true;
            foreach (ITypeParameterMember itpm in typeParameterMembers.Values)
            {
                if (firstMember)
                    firstMember = false;
                else
                    base.WriteLine(", _", TranslatorFormatterTokenType.Operator);
                TranslateConceptIdentifier(itpm);
                if (typeParameterMembers.TargetDeclaration is ISegmentableDeclaredType && (((ISegmentableDeclaredType)(typeParameterMembers.TargetDeclaration)).IsPartial))
                    continue;
                if (itpm.Constraints != null && itpm.Constraints.Count > 0 || itpm.SpecialCondition != TypeParameterSpecialCondition.None || itpm.RequiresConstructor)
                    TranslateConstraints(itpm);
            }
            base.Write(")", TranslatorFormatterTokenType.Operator);
            base.DecreaseIndent();
        }

        public override void TranslateParameters<TParameter, TParameteredDom, TParent>(IParameteredParameterMembers<TParameter, TParameteredDom, TParent> parameterMembers)
        {
            if (parameterMembers == null)
                return;
            base.Write("(", TranslatorFormatterTokenType.Operator);
            bool firstMember = true;
            foreach (TParameter tpm in parameterMembers.Values)
            {
                if (firstMember)
                    firstMember = false;
                else
                    base.Write(", ", TranslatorFormatterTokenType.Operator);
                TranslateMember(tpm);
            }
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an array indexer expression.  That is an expression that accesses the
        /// <see cref="IArrayIndexerExpression.Reference"/> as if it were an array.
        /// </summary>
        /// <param name="arrayIndexerExpression">The <see cref="IArrayIndexerExpression"/> to translate.</param>
        public override void TranslateExpression(IArrayIndexerExpression arrayIndexerExpression)
        {
            TranslateExpression(arrayIndexerExpression.Reference);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            TranslateExpressionGroup(arrayIndexerExpression.Indices);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates a binary operation expression, or an expression that has a <see cref="IBinaryOperationExpression.LeftSide"/> and
        /// <see cref="IBinaryOperationExpression.RightSide"/> demarcated by the operator <see cref="IBinaryOperationExpression.Operation"/>
        /// in standard implementations.
        /// </summary>
        /// <param name="binOpExpression">The <see cref="IBinaryOperationExpression"/> to translate.</param>
        public override void TranslateExpression(IBinaryOperationExpression binOpExpression)
        {
            if (binOpExpression.Operation != CodeBinaryOperatorType.ValueEquality)
                TranslateExpression(binOpExpression.LeftSide);
            switch (binOpExpression.Operation)
            {
                case System.CodeDom.CodeBinaryOperatorType.Add:
                    base.Write(" + ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.Assign:
                    base.Write(" = ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.BitwiseAnd:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.And);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.BitwiseOr:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Or);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.BooleanAnd:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.AndAlso);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.BooleanOr:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.OrElse);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.Divide:
                    base.Write(" / ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.GreaterThan:
                    base.Write(" > ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.GreaterThanOrEqual:
                    base.Write(" >= ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.IdentityEquality:
                    base.Write(" = ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.IdentityInequality:
                    base.Write(" <> ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.LessThan:
                    base.Write(" < ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.LessThanOrEqual:
                    base.Write(" <= ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.Modulus:
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    TranslateConceptKeyword(Keywords.Mod);
                    base.Write(" ", TranslatorFormatterTokenType.Other);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.Multiply:
                    base.Write(" * ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.Subtract:
                    base.Write(" - ", TranslatorFormatterTokenType.Operator);
                    break;
                case System.CodeDom.CodeBinaryOperatorType.ValueEquality:
                    TranslateConceptTypeName(typeof(object).GetTypeReference());
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                    base.Write("Equals", TranslatorFormatterMemberType.Method);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    TranslateExpression(binOpExpression.LeftSide);
                    base.Write(", ", TranslatorFormatterTokenType.Operator);
                    TranslateExpression(binOpExpression.RightSide);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                default:
                    break;
            }
            if (binOpExpression.Operation != CodeBinaryOperatorType.ValueEquality)
                TranslateExpression(binOpExpression.RightSide);
        }

        /// <summary>
        /// Translates an expression used to cast another expression to the desired type.
        /// </summary>
        /// <param name="castExpression">The <see cref="ICastExpression"/> to translate.</param>
        public override void TranslateExpression(ICastExpression castExpression)
        {
            TranslateConceptKeyword(Keywords.CType);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            this.TranslateExpression(castExpression.Target);
            base.Write(", ", TranslatorFormatterTokenType.Operator);
            this.TranslateConceptTypeName(castExpression.Type);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an expression used to instanciate an array instance.
        /// </summary>
        /// <param name="expression">The <see cref="ICreateArrayExpression"/> to translate.</param>
        public override void TranslateExpression(ICreateArrayExpression expression)
        {
            TranslateConceptKeyword(Keywords.New);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            this.TranslateConceptTypeName(expression.ArrayType);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            if (expression.SizeExpression != null)
                this.TranslateExpression((Expression.Expression)expression.SizeExpression - 1);
            else if ((expression.Initializers == null) || (expression.Initializers.Count == 0))
                base.Write("-1", TranslatorFormatterTokenType.Number);
            base.Write(")", TranslatorFormatterTokenType.Operator);
            base.IncreaseIndent();
            base.WriteLine(" _", TranslatorFormatterTokenType.Operator);
            base.Write("{", TranslatorFormatterTokenType.Operator);
            if ((expression.Initializers != null) && (expression.Initializers.Count > 0))
            {
                this.TranslateExpressionGroup(expression.Initializers);
            }
            base.Write("}", TranslatorFormatterTokenType.Operator);
            base.DecreaseIndent();
        }

        /// <summary>
        /// Translates an expression used to create an object instance.
        /// </summary>
        /// <param name="expression">The <see cref="ICreateNewObjectExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(ICreateNewObjectExpression expression)
        {
            TranslateConceptKeyword(Keywords.New);
            base.Write(" ", TranslatorFormatterTokenType.Other);
            TranslateConceptTypeName(expression.NewType);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            TranslateExpressionGroup(expression.Arguments);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an expression used to direct a parameter in a method invoke parameter
        /// list.
        /// </summary>
        /// <param name="directionExpression">The <see cref="IDirectionExpression"/> to be
        /// translated.</param>
        /// <remarks>Not supported in the visual basic language.</remarks>
        public override void TranslateExpression(IDirectionExpression directionExpression)
        {

        }

        /// <summary>
        /// Translates an expression used to reference a property or field event.
        /// </summary>
        /// <param name="eventReferenceExpression">The <see cref="IEventReferenceExpression"/>
        /// to be translated.</param>
        public override void TranslateExpression(IEventReferenceExpression eventReferenceExpression)
        {
            this.TranslateExpression(eventReferenceExpression.Reference);
            this.TranslateConceptIdentifier(eventReferenceExpression.Name, TranslatorFormatterMemberType.Event);
        }

        /// <summary>
        /// Translates an expression used to reference a field.
        /// </summary>
        /// <param name="fieldRefExpression">The <see cref="IFieldReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IFieldReferenceExpression fieldRefExpression)
        {
            if (fieldRefExpression.Reference is ITypeReferenceExpression && ((ITypeReferenceExpression)(fieldRefExpression.Reference)).TypeReference is IDeclaredTypeReference)
            {
                IDeclaredType idt = ((IDeclaredTypeReference)(((ITypeReferenceExpression)(fieldRefExpression.Reference)).TypeReference)).TypeInstance;
                if (idt is ISegmentableDeclaredType)
                    idt = ((ISegmentableDeclaredType)(idt)).GetRootDeclaration();
                if (!base.Options.BuildTrail.Contains(idt))
                {
                    this.TranslateExpression(fieldRefExpression.Reference);
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                }
            }
            else
            {
                this.TranslateExpression(fieldRefExpression.Reference);
                base.Write(".", TranslatorFormatterTokenType.Operator);
            }
            if (fieldRefExpression is FieldMember.ReferenceExpression)
                this.TranslateConceptIdentifier(((FieldMember.ReferenceExpression)fieldRefExpression).referencePoint);
            else
                this.TranslateConceptIdentifier(fieldRefExpression.Name, TranslatorFormatterMemberType.Field);
        }

        /// <summary>
        /// Translates an expression used to retrieve a resource from the project or
        /// [current] type resources.
        /// </summary>
        /// <param name="getResourceExpression"></param>
        public override void TranslateExpression(IGetResourceExpression getResourceExpression)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        /// <summary>
        /// Translates an expression used to reference and access an instance or type indexer.
        /// </summary>
        /// <param name="indexerRefExpression">The <see cref="IIndexerReferenceExpression"/> to 
        /// be translated.</param>
        public override void TranslateExpression(IIndexerReferenceExpression indexerRefExpression)
        {
            this.TranslateExpression(indexerRefExpression.Reference);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            this.TranslateExpressionGroup(indexerRefExpression.Indices);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an expression used to reference a local (method) member.
        /// </summary>
        /// <param name="localRefExpression">The <see cref="ILocalReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(ILocalReferenceExpression localRefExpression)
        {
            if (localRefExpression is StatementBlockLocalMember.ReferenceExpression)
            {
                this.TranslateConceptIdentifier(((StatementBlockLocalMember.ReferenceExpression)localRefExpression).referencePoint);
            }
            else
                this.TranslateConceptIdentifier(localRefExpression.Name, TranslatorFormatterMemberType.Local);
        }

        /// <summary>
        /// Translates an expression used to invoke a method.
        /// </summary>
        /// <param name="methodInvExpression">The <see cref="IMethodInvokeExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IMethodInvokeExpression methodInvExpression)
        {
            this.TranslateExpression(methodInvExpression.Reference);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            this.TranslateExpressionGroup(methodInvExpression.ArgumentExpressions);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an expression used to reference a method.
        /// </summary>
        /// <param name="methodRefExpression">The <see cref="IMethodReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IMethodReferenceExpression methodRefExpression)
        {
            bool includeReference = true;
            if (methodRefExpression.Reference is ITypeReferenceExpression && ((ITypeReferenceExpression)(methodRefExpression.Reference)).TypeReference is IDeclaredTypeReference)
            {
                IDeclaredType idt = ((IDeclaredTypeReference)(((ITypeReferenceExpression)(methodRefExpression.Reference)).TypeReference)).TypeInstance;
                if (idt is ISegmentableDeclaredType)
                    idt = ((ISegmentableDeclaredType)(idt)).GetRootDeclaration();
                if (base.Options.BuildTrail.Contains(idt))
                    includeReference = false;
            }
            if (methodRefExpression is MethodMember.ReferenceExpression)
            {
                if (includeReference)
                {
                    MethodMember.ReferenceExpression mmre = methodRefExpression as MethodMember.ReferenceExpression;
                    if ((mmre.referencePoint.PrivateImplementationTarget == null) || (mmre.Reference is ICastExpression))
                    {
                        this.TranslateExpression(methodRefExpression.Reference);
                        base.Write(".", TranslatorFormatterTokenType.Operator);
                    }
                    else
                    {
                        this.TranslateExpression(new CastExpression(methodRefExpression.Reference, mmre.referencePoint.PrivateImplementationTarget));
                        base.Write(".", TranslatorFormatterTokenType.Operator);
                    }
                }
                this.TranslateConceptIdentifier(((MethodMember.ReferenceExpression)methodRefExpression).referencePoint);
            }
            else
            {
                if (includeReference)
                {
                    this.TranslateExpression(methodRefExpression.Reference);
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                }
                this.TranslateConceptIdentifier(methodRefExpression.Name, TranslatorFormatterMemberType.Method);
            }
            if (methodRefExpression.TypeArguments != null && methodRefExpression.TypeArguments.Count > 0)
            {
                base.Write("(", TranslatorFormatterTokenType.Operator);
                TranslateConceptKeyword(Keywords.Of);
                base.Write(" ", TranslatorFormatterTokenType.Other);
                this.TranslateTypeReferenceCollection(methodRefExpression.TypeArguments);
                base.Write(")", TranslatorFormatterTokenType.Operator);
            }
        }

        /// <summary>
        /// Translates an expression used to reference a parameter.
        /// </summary>
        /// <param name="paramRefExpression">The <see cref="IParameterReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IParameterReferenceExpression paramRefExpression)
        {
            if (paramRefExpression is MethodParameterMember.ReferenceExpression)
                this.TranslateConceptIdentifier(((MethodParameterMember.ReferenceExpression)paramRefExpression).referencePoint);
            else if (paramRefExpression is IndexerParameterMember.ReferenceExpression)
                this.TranslateConceptIdentifier(((IndexerParameterMember.ReferenceExpression)paramRefExpression).referencePoint);
            else
                this.TranslateConceptIdentifier(paramRefExpression.Name, TranslatorFormatterMemberType.Parameter);
        }

        /// <summary>
        /// Translates a primitive [literal] expression.
        /// </summary>
        /// <param name="primitiveExpression">The <see cref="IPrimitiveExpression"/> to be 
        /// translated.</param>
        public override void TranslateExpression(IPrimitiveExpression primitiveExpression)
        {
            switch (primitiveExpression.TypeCode)
            {
                case TypeCode.Boolean:
                    switch ((bool)primitiveExpression.Value)
                    {
                        case true:
                            TranslateConceptKeyword(Keywords.True);
                            break;
                        case false:
                            TranslateConceptKeyword(Keywords.False);
                            break;
                    }
                    return;
                case TypeCode.Byte:
                    TranslateConceptKeyword(Keywords.CByte);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    return;
                case TypeCode.Char:
                    base.Write(EscapeString(primitiveExpression.Value.ToString(), base.Target.Indent), TranslatorFormatterTokenType.Number);
                    base.Write("c", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.Double:
                    break;
                case TypeCode.Empty:
                    TranslateConceptKeyword(Keywords.Nothing);
                    break;
                case TypeCode.Int16:
                    TranslateConceptKeyword(Keywords.CShort);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.Int32:
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    break;
                case TypeCode.Int64:
                    TranslateConceptKeyword(Keywords.CLng);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.SByte:
                    TranslateConceptKeyword(Keywords.CSByte);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.Single:
                    TranslateConceptKeyword(Keywords.CSng);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.String:
                    base.Write(EscapeString(primitiveExpression.Value.ToString(), base.Target.Indent), TranslatorFormatterTokenType.String);
                    break;
                case TypeCode.UInt16:
                    TranslateConceptKeyword(Keywords.CUShort);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.UInt32:
                    TranslateConceptKeyword(Keywords.CUInt);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);
                    break;
                case TypeCode.UInt64:
                    TranslateConceptKeyword(Keywords.CULng);
                    base.Write("(", TranslatorFormatterTokenType.Operator);
                    base.Write(primitiveExpression.Value.ToString(), TranslatorFormatterTokenType.Number);
                    base.Write(")", TranslatorFormatterTokenType.Operator);

                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Translates an expression used to reference a property.
        /// </summary>
        /// <param name="propRefExpression">The <see cref="IPropertyReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IPropertyReferenceExpression propRefExpression)
        {
            bool includeReference = true;
            if (propRefExpression.Reference is ITypeReferenceExpression && ((ITypeReferenceExpression)(propRefExpression.Reference)).TypeReference is IDeclaredTypeReference)
            {
                IDeclaredType idt = ((IDeclaredTypeReference)(((ITypeReferenceExpression)(propRefExpression.Reference)).TypeReference)).TypeInstance;
                if (idt is ISegmentableDeclaredType)
                    idt = ((ISegmentableDeclaredType)(idt)).GetRootDeclaration();
                if (base.Options.BuildTrail.Contains(idt))
                    includeReference = false;
            }
            if (propRefExpression is PropertyMember.ReferenceExpression)
            {
                PropertyMember.ReferenceExpression mmre = propRefExpression as PropertyMember.ReferenceExpression;
                if (includeReference)
                {
                    if ((mmre.referencePoint.PrivateImplementationTarget == null) || (mmre.Reference is ICastExpression))
                    {
                        this.TranslateExpression(propRefExpression.Reference);
                        base.Write(".", TranslatorFormatterTokenType.Operator);
                    }
                    else
                    {
                        this.TranslateExpression(new CastExpression(propRefExpression.Reference, mmre.referencePoint.PrivateImplementationTarget));
                        base.Write(".", TranslatorFormatterTokenType.Operator);
                    }
                }
                this.TranslateConceptIdentifier(((PropertyMember.ReferenceExpression)propRefExpression).referencePoint);
            }
            else
            {
                if (includeReference)
                {
                    this.TranslateExpression(propRefExpression.Reference);
                    base.Write(".", TranslatorFormatterTokenType.Operator);
                }
                this.TranslateConceptIdentifier(propRefExpression.Name, TranslatorFormatterMemberType.Method);
            }
        }

        /// <summary>
        /// Translates an expression used to refer to the value parameter used in a property set method.
        /// </summary>
        /// <param name="propSetValRefExpression">The <see cref="IPropertySetValueReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IPropertySetValueReferenceExpression propSetValRefExpression)
        {
            base.Write("value", TranslatorFormatterTokenType.Keyword);
        }

        /// <summary>
        /// Translates an expression used to refer to the current instanciable instance.
        /// </summary>
        /// <param name="thisRefExpression">The <see cref="IThisReferenceExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(IThisReferenceExpression thisRefExpression)
        {
            TranslateConceptKeyword(Keywords.Me);
        }

        /// <summary>
        /// Translates an expression used to return the <see cref="System.Type"/> of an identifier
        /// that resolves to a type.
        /// </summary>
        /// <param name="typeOfExpression">The <see cref="ITypeOfExpression"/> to be
        /// translated.</param>
        public override void TranslateExpression(ITypeOfExpression typeOfExpression)
        {
            TranslateConceptKeyword(Keywords.GetType);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            TranslateConceptTypeName(typeOfExpression.TypeReference);
            base.Write(")", TranslatorFormatterTokenType.Operator);
        }

        /// <summary>
        /// Translates an expression that refers to a <see cref="System.Type"/>.
        /// </summary>
        /// <param name="typeRefExpression">The <see cref="ITypeReferenceExpression"/> to be translated.</param>
        public override void TranslateExpression(ITypeReferenceExpression typeRefExpression)
        {
            this.TranslateConceptTypeName(typeRefExpression.TypeReference);
        }

        /// <summary>
        /// Translates an expression collection.
        /// </summary>
        /// <param name="expressions">The series of <see cref="IExpression"/> instance implementations
        /// to be translated.</param>
        public override void TranslateExpressionGroup(IExpressionCollection expressions)
        {
            bool flag = true;
            if (expressions.Count == 0)
                return;
            base.IncreaseIndent();
            foreach (IExpression iexp in expressions)
            {
                if (flag)
                    flag = false;
                else
                    base.WriteLine(", _", TranslatorFormatterTokenType.Operator);
                this.TranslateExpression(iexp);
            }
            base.DecreaseIndent();
        }

        /// <summary>
        /// Translates a series of <see cref="ITypeReference"/> instances to their string form.
        /// </summary>
        /// <param name="typeRefCol">The series of <see cref="ITypeReference"/> instances to 
        /// translate.</param>
        /// <remarks>Comma-delimeted list of <see cref="ITypeReference"/> names.</remarks>
        public override void TranslateTypeReferenceCollection(ITypeReferenceCollection typeRefCol)
        {
            bool first = true;
            foreach (ITypeReference itr in typeRefCol)
            {
                if (first)
                    first = false;
                else
                    base.Write(", ", TranslatorFormatterTokenType.Operator);
                this.TranslateConceptTypeName(itr);
            }
        }

        private bool GetTypeName(Type type, ref StringBuilder target)
        {
            if (target == null)
                target = new StringBuilder();
            if (VBAutoFormTypeLookup.ContainsKey(type))
            {
                target.Append(GetKeywordText(VBAutoFormTypeLookup[type]));
                return true;
            }
            return false;
        }

        public override void TranslateConceptTypeName(ITypeReference typeRef)
        {
            base.Write(GetTypeName(typeRef), TranslatorFormatterTokenType.Preformatted);
        }

        private string GetTypeName(ITypeReference typeRef)
        {
            StringBuilder result = new StringBuilder();
            this.GetTypeName(typeRef, ref result);
            return result.ToString();
        }

        private void GetTypeName(ITypeReference typeReference, ref StringBuilder target)
        {
            if (!(typeReference.ArrayElementType == null || typeReference.ArrayRank == 0))
            {
                this.GetTypeName(typeReference.ArrayElementType, ref target);
                target.Append("(");
                bool flag = true;
                for (int i = 0; i < typeReference.ArrayRank; i++)
                    if (flag)
                        flag = false;
                    else
                        target.Append(",");
                target.Append(")");
            }
            else
            {
                if (typeReference is IExternTypeReference)
                    GetTypeName((IExternTypeReference)typeReference, typeReference.TypeParameters, ref target);
                else if (typeReference is IDeclaredTypeReference)
                    GetTypeName((IDeclaredTypeReference)typeReference, typeReference.TypeParameters, ref target);
                if (typeReference.TypeInstance is ITypeParameterMember)
                    GetTypeName((ITypeParameterMember)typeReference.TypeInstance, ref target);
            }
        }

        public override sealed void TranslateConceptTypeName(IExternTypeReference typeRef, ITypeReferenceCollection typeParameters)
        {
            base.Write(GetTypeName(typeRef, typeParameters), TranslatorFormatterTokenType.Preformatted);
        }

        private string GetTypeName(IExternTypeReference typeReference, ITypeReferenceCollection typeParameters)
        {
            StringBuilder sb = new StringBuilder();
            GetTypeName(typeReference, typeParameters, ref sb);
            return sb.ToString();
        }

        private void GetTypeName(IExternTypeReference typeRef, ITypeReferenceCollection typeParameters, ref StringBuilder target)
        {
            if (target == null)
                target = new StringBuilder();
            IExternType type = typeRef.TypeInstance;
            if (GetTypeName(type.Type, ref target))
                return;
            List<ITypeReference> typeParams = new List<ITypeReference>(typeParameters);
            typeParams.Reverse();
            Stack<ITypeReference> typeParamsStack = new Stack<ITypeReference>(typeParams);

            List<Type> hierarchy = new List<Type>();

            for (Type t = type.Type; t != null; t = t.DeclaringType)
                hierarchy.Add(t);
            hierarchy.Reverse();
            if (((typeRef.ResolutionOptions & TypeReferenceResolveOptions.GlobalType) == TypeReferenceResolveOptions.GlobalType))
            {
                target.Append(GetKeywordText(Keywords.Global) + base.GetFormat(".", TranslatorFormatterTokenType.Operator));
            }
            if (!(type.Type.IsGenericParameter || base.Options.AutoResolveReferences) || ((typeRef.ResolutionOptions & TypeReferenceResolveOptions.FullType) == TypeReferenceResolveOptions.FullType) || ((typeRef.ResolutionOptions & TypeReferenceResolveOptions.GlobalType) == TypeReferenceResolveOptions.GlobalType))
                target.Append(base.GetFormat(string.Format("{0}.", type.Type.Namespace), TranslatorFormatterTokenType.NameSpace));
            Dictionary<Type, List<Type>> genParams = new Dictionary<Type, List<Type>>();
            bool flag = true;
            int index = 0;
            foreach (Type t in hierarchy)
            {
                index++;
                bool isLast = index == hierarchy.Count;
                genParams[t] = new List<Type>();
                if (t.IsGenericType)
                    genParams[t].AddRange(t.GetGenericArguments());
                if (t.DeclaringType != null)
                    //Children include their parents' type-arguments.
                    for (Type t3 = t.DeclaringType; t3 != null; t3 = t3.DeclaringType)
                        foreach (Type t2 in genParams[t3])
                            genParams[t].RemoveAt(0);
                string tName = t.Name;
                if (tName.Contains("`"))
                    tName = tName.Substring(0, tName.IndexOf('`'));
                if (flag)
                    flag = false;
                else
                    target.Append(base.GetFormat(".", TranslatorFormatterTokenType.Operator));

                target.Append(base.GetFormat(this.GetConceptIdentifier(tName), (ExternType)t));
                if (genParams[t].Count > 0)
                {
                    target.Append(base.GetFormat("(", TranslatorFormatterTokenType.Operator) + this.GetKeywordText(Keywords.Of) + base.GetFormat(" ", TranslatorFormatterTokenType.Other));
                    bool flag2 = true;
                    foreach (Type t2 in genParams[t])
                    {
                        if (flag2)
                            flag2 = false;
                        else
                            target.Append(base.GetFormat(", ", TranslatorFormatterTokenType.Operator));
                        if (typeParamsStack.Count > 0)
                            this.GetTypeName(typeParamsStack.Pop(), ref target);
                    }
                    target.Append(base.GetFormat(")", TranslatorFormatterTokenType.Operator));
                }
            }
        }

        public override sealed void TranslateConceptTypeName(IDeclaredTypeReference typeReference, ITypeReferenceCollection typeParameters)
        {
            base.Write(GetTypeName(typeReference, typeParameters), TranslatorFormatterTokenType.Preformatted);
        }

        private string GetTypeName(IDeclaredTypeReference typeReference, ITypeReferenceCollection typeParameters)
        {
            StringBuilder sb = new StringBuilder();
            GetTypeName(typeReference, typeParameters, ref sb);
            return sb.ToString();
        }
        private void GetTypeName(IDeclaredTypeReference typeReference, ITypeReferenceCollection typeParameters, ref StringBuilder target)
        {
            if (target == null)
                target = new StringBuilder();
            List<IDeclaredType> hierarchy;
            Stack<ITypeReference> typeParamsStack;
            _OIL._Core.GetDeclaredHierarchy(typeReference, typeParameters, out hierarchy, out typeParamsStack);
            bool flag = true;
            if (!base.Options.AutoResolveReferences || (typeReference.ResolutionOptions & TypeReferenceResolveOptions.FullType) == TypeReferenceResolveOptions.FullType)
            {
                IDeclarationTarget idt = hierarchy[0].ParentTarget;
                if ((typeReference.ResolutionOptions & TypeReferenceResolveOptions.GlobalType) == TypeReferenceResolveOptions.GlobalType)
                    target.Append(GetKeywordText(Keywords.Global) + ".");
                if (idt is INameSpaceDeclaration)
                    target.Append(base.GetFormat(idt.Name + ".", TranslatorFormatterTokenType.NameSpace));
            }
            else if ((typeReference.ResolutionOptions & TypeReferenceResolveOptions.GlobalType) == TypeReferenceResolveOptions.GlobalType)
                target.Append(GetKeywordText(Keywords.Global) + ".");
            for (int j = 0; j < hierarchy.Count; j++)
            {
                IDeclaredType idt;
                if (hierarchy[j] is ISegmentableDeclaredType)
                    idt = ((ISegmentableDeclaredType)hierarchy[j]).GetRootDeclaration();
                else
                    idt = hierarchy[j];
                bool isLast = (idt == hierarchy[hierarchy.Count - 1]);
                bool excluded = false;
                excluded = (!isLast && base.Options.BuildTrail.Contains(idt));
                if (!excluded)
                {
                    if (flag)
                        flag = false;
                    else
                        target.Append(".");
                    target.Append(base.GetFormat(GetConceptIdentifier(idt), idt));
                    if (idt.IsGeneric && idt is IParameteredDeclaredType)
                    {
                        IParameteredDeclaredType ipdt = ((IParameteredDeclaredType)(idt));
                        if (ipdt.TypeParameters != null && ipdt.TypeParameters.Count > 0)
                        {
                            target.Append(GetFormat("(", TranslatorFormatterTokenType.Operator) + this.GetKeywordText(Keywords.Of) + base.GetFormat(" ", TranslatorFormatterTokenType.Other));
                            bool flag2 = true;
                            for (int i = 0; i < ipdt.TypeParameters.Count; i++)
                            {
                                if (flag2)
                                    flag2 = false;
                                else
                                    target.Append(base.GetFormat(", ", TranslatorFormatterTokenType.Operator));
                                this.GetTypeName(typeParamsStack.Pop(), ref target);
                            }
                            target.Append(GetFormat(")", TranslatorFormatterTokenType.Operator));
                        }
                    }
                }
                else if (idt.IsGeneric && idt is IParameteredDeclaredType && ((IParameteredDeclaredType)idt).TypeParameters != null && ((IParameteredDeclaredType)idt).TypeParameters.Count > 0)
                    for (int i = 0; i < ((IParameteredDeclaredType)idt).TypeParameters.Count; i++)
                        typeParamsStack.Pop();
            }
        }

        public override sealed void TranslateConceptTypeName(ITypeParameterMember type, ITypeReferenceCollection typeParameters)
        {
            base.Write(GetTypeName(type), TranslatorFormatterTokenType.Preformatted);
        }

        private string GetTypeName(ITypeParameterMember type)
        {
            StringBuilder sb = new StringBuilder();
            GetTypeName(type, ref sb);
            return sb.ToString();
        }
        private void GetTypeName(ITypeParameterMember type, ref StringBuilder target)
        {
            target.Append(GetConceptIdentifier(type));
        }

        public override void TranslateConstraints<TDom, TParent>(ITypeParameterMember<TDom, TParent> ambigTypeParamMember)
        {
            base.IncreaseIndent();
            List<ITypeReference> typeRefClasses = new List<ITypeReference>();
            List<ITypeReference> typeRefInterfaces = new List<ITypeReference>();
            foreach (ITypeReference itr in ambigTypeParamMember.Constraints)
                if (itr.TypeInstance.IsClass || itr.TypeInstance.IsDelegate)
                    typeRefClasses.Add(itr);
                else if (itr.TypeInstance.IsInterface || itr.TypeInstance is ITypeParameterMember)
                    typeRefInterfaces.Add(itr);
                else
                    throw new NotSupportedException("Cannot use a constraint of given type.");
            int count = 0;
            if (ambigTypeParamMember.SpecialCondition == TypeParameterSpecialCondition.Class)
                count++;
            else if (ambigTypeParamMember.SpecialCondition == TypeParameterSpecialCondition.ValueType)
                count++;
            else
                count += typeRefClasses.Count;
            count += typeRefInterfaces.Count;
            if (ambigTypeParamMember.RequiresConstructor)
                count++;
            if (count > 0)
            {
                base.Write(" ", TranslatorFormatterTokenType.Other);
                TranslateConceptKeyword(Keywords.As);
                base.Write(" ", TranslatorFormatterTokenType.Other);
            }
            if (count > 1)
                base.Write("{", TranslatorFormatterTokenType.Operator);
            if (ambigTypeParamMember.Constraints.Count > 0 || (ambigTypeParamMember.SpecialCondition != TypeParameterSpecialCondition.None) | ambigTypeParamMember.RequiresConstructor)
            {
                base.IncreaseIndent();
                bool firstMember = true;
                List<ITypeReference> typeRefArranged = new List<ITypeReference>();
                switch (ambigTypeParamMember.SpecialCondition)
                {
                    case TypeParameterSpecialCondition.Class:
                        this.TranslateConceptKeyword(Keywords.Class);
                        firstMember = false;
                        break;
                    case TypeParameterSpecialCondition.ValueType:
                        this.TranslateConceptKeyword(Keywords.Structure);
                        firstMember = false;
                        break;
                    case TypeParameterSpecialCondition.None:
                    default:
                        typeRefArranged.AddRange(typeRefClasses);
                        break;
                }
                typeRefArranged.AddRange(typeRefInterfaces);
                foreach (ITypeReference itr in typeRefArranged)
                {
                    if (firstMember)
                        firstMember = false;
                    else
                        base.Write(", ", TranslatorFormatterTokenType.Operator);
                    this.TranslateConceptTypeName(itr);
                }
                if (ambigTypeParamMember.RequiresConstructor)
                {
                    if (!firstMember)
                        base.Write(", ", TranslatorFormatterTokenType.Operator);
                    this.TranslateConceptKeyword(Keywords.New);
                }
                base.DecreaseIndent();
            }
            if (count > 1)
                base.Write("}", TranslatorFormatterTokenType.Operator);
            base.DecreaseIndent();
        }

        public override void TranslateConceptComment(string commentBase, bool docComment)
        {
            string result = _OIL._Core.GetVBCommentText(commentBase, docComment);
            string[] resultLines = result.Split(new string[] { "\r\n" }, StringSplitOptions.None);
            foreach (string s in resultLines)
                base.WriteLine(s, TranslatorFormatterTokenType.Comment);
        }

        /// <summary>
        /// Returns the string which denotes the sub-tool version.  
        /// Relates specifically to the individual language implementation.
        /// </summary>
        public override string SubToolVersion
        {
            get { return "1.0.0.0"; }
        }

        /// <summary>
        /// Returns the string which denotes the sub-tool's name.
        /// Relates specifically to the individual language implementation.
        /// </summary>
        public override string SubToolName
        {
            get { return "Oilexer.VBCodeTranslator"; }
        }

        /// <summary>
        /// Returns the name of the language implemented by the sub-tool.
        /// </summary>
        public override string Language
        {
            get { return string.Format("Visual Basic.NET (Runtime version: {0})", typeof(string).Assembly.ImageRuntimeVersion); }
        }

        /// <summary>
        /// Translates a single <see cref="IAttributeDeclaration"/> onto the declaration of <paramref name="attributeSource"/>.
        /// </summary>
        /// <param name="attributeSource">The <see cref="IAttributeDeclarationTarget"/> which
        /// contains the <see cref="IAttributeDeclaration"/>.</param>
        /// <remarks>The <paramref name="attributeSource"/> is used to reduce the
        /// emission based upon whether the target is segmentable.
        /// To prevent errors on non-multi-use attributes, partial targets have attributes 
        /// on the root instance only.</remarks>
        public override void TranslateAttribute(IAttributeDeclarationTarget attributeSource, IAttributeDeclaration attribute)
        {
            IAttributeConstructorParameter[] normal = Tweaks.FilterArray<IAttributeConstructorParameter>(attribute.Parameters.ToArray(), delegate(IAttributeConstructorParameter param) { return (!(param is IAttributePropertyParameter)); });
            IAttributeConstructorParameter[] named = Tweaks.FilterArray<IAttributeConstructorParameter>(attribute.Parameters.ToArray(), delegate(IAttributeConstructorParameter param) { return (param is IAttributePropertyParameter); });
            //translatingAttributeTypeName = true;
            base.Write("<", TranslatorFormatterTokenType.Operator);
            this.TranslateConceptTypeName(attribute.AttributeType);
            base.Write("(", TranslatorFormatterTokenType.Operator);
            bool firstMember = true;
            foreach (IAttributeConstructorParameter normalParam in normal)
            {
                if (firstMember)
                    firstMember = false;
                else
                    base.Write(", ", TranslatorFormatterTokenType.Operator);
                this.TranslateExpression(normalParam.Value);
            }

            foreach (IAttributePropertyParameter propParam in named)
            {
                if (firstMember)
                    firstMember = false;
                else
                    base.Write(", ", TranslatorFormatterTokenType.Operator);
                this.TranslateConceptIdentifier(propParam.Name, TranslatorFormatterMemberType.Property);
                base.Write(" = ", TranslatorFormatterTokenType.Operator);
                this.TranslateExpression(propParam.Value);
            }
            base.WriteLine(")> _", TranslatorFormatterTokenType.Operator);
        }

        public override void TranslateConceptRegionStart(string regionText)
        {
            base.Write("#Region ", TranslatorFormatterTokenType.Keyword);
            base.WriteLine(this.EscapeString(regionText, base.Target.Indent), TranslatorFormatterTokenType.String);
        }

        public override void TranslateConceptRegionEnd(string regionText)
        {
            base.Write("' ", TranslatorFormatterTokenType.Comment);
            base.WriteLine(regionText, TranslatorFormatterTokenType.String);
            base.Write("#End Region", TranslatorFormatterTokenType.Keyword);
            base.WriteLine();
        }

        private void TranslateConceptKeyword(Keywords keyWord)
        {
            string keyWordText = GetKeywordText(keyWord);
            if (keyWordText != null && keyWordText != String.Empty)
                base.Write(keyWordText, TranslatorFormatterTokenType.Preformatted);
        }

        private string GetKeywordText(Keywords keyWord)
        {
            string result = "";
            goto __keywordGet;
        __keywordEcho:
            return base.GetFormat(result, TranslatorFormatterTokenType.Keyword);
        __keywordGet:
            switch (keyWord)
            {
                case Keywords.As:
                case Keywords.Do:
                case Keywords.If:
                case Keywords.In:
                case Keywords.Is:
                case Keywords.Me:
                case Keywords.Of:
                case Keywords.On:
                case Keywords.Or:
                case Keywords.To:
                    result = keywordLookup[2][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.And:
                case Keywords.Dim:
                case Keywords.End:
                case Keywords.For:
                case Keywords.Get:
                case Keywords.Let:
                case Keywords.Lib:
                case Keywords.Mod:
                case Keywords.New:
                case Keywords.Not:
                case Keywords.Rem:
                case Keywords.Set:
                case Keywords.Sub:
                case Keywords.Try:
                case Keywords.XOr:
                    result = keywordLookup[3][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.Ansi:
                case Keywords.Auto:
                case Keywords.Byte:
                case Keywords.Call:
                case Keywords.Case:
                case Keywords.CDbl:
                case Keywords.CDec:
                case Keywords.Char:
                case Keywords.CInt:
                case Keywords.CLng:
                case Keywords.CObj:
                case Keywords.CSng:
                case Keywords.CStr:
                case Keywords.Date:
                case Keywords.Each:
                case Keywords.Else:
                case Keywords.Enum:
                case Keywords.Exit:
                case Keywords.GoTo:
                case Keywords.Like:
                case Keywords.Long:
                case Keywords.Loop:
                case Keywords.Next:
                case Keywords.Step:
                case Keywords.Stop:
                case Keywords.Then:
                case Keywords.True:
                case Keywords.Wend:
                case Keywords.When:
                case Keywords.With:
                    result = keywordLookup[4][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.Alias:
                case Keywords.ByRef:
                case Keywords.ByVal:
                case Keywords.Catch:
                case Keywords.CBool:
                case Keywords.CByte:
                case Keywords.CChar:
                case Keywords.CDate:
                case Keywords.Class:
                case Keywords.Const:
                case Keywords.CType:
                case Keywords.CUInt:
                case Keywords.CULng:
                case Keywords.EndIf:
                case Keywords.Erase:
                case Keywords.Error:
                case Keywords.Event:
                case Keywords.False:
                case Keywords.GoSub:
                case Keywords.IsNot:
                case Keywords.ReDim:
                case Keywords.SByte:
                case Keywords.Short:
                case Keywords.Throw:
                case Keywords.ULong:
                case Keywords.Until:
                case Keywords.Using:
                case Keywords.While:
                    result = keywordLookup[5][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.CSByte:
                case Keywords.CShort:
                case Keywords.Double:
                case Keywords.ElseIf:
                case Keywords.Friend:
                case Keywords.Global:
                case Keywords.Module:
                case Keywords.MyBase:
                case Keywords.Object:
                case Keywords.Option:
                case Keywords.OrElse:
                case Keywords.Public:
                case Keywords.Resume:
                case Keywords.Return:
                case Keywords.Select:
                case Keywords.Shared:
                case Keywords.Single:
                case Keywords.Static:
                case Keywords.String:
                case Keywords.TypeOf:
                case Keywords.UShort:
                    result = keywordLookup[6][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.AndAlso:
                case Keywords.Boolean:
                case Keywords.CUShort:
                case Keywords.Decimal:
                case Keywords.Declare:
                case Keywords.Default:
                case Keywords.Finally:
                case Keywords.GetType:
                case Keywords.Handles:
                case Keywords.Imports:
                case Keywords.Integer:
                case Keywords.MyClass:
                case Keywords.Nothing:
                case Keywords.Partial:
                case Keywords.Private:
                case Keywords.Shadows:
                case Keywords.TryCast:
                case Keywords.Unicode:
                case Keywords.Variant:
                    result = keywordLookup[7][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.Assembly:
                case Keywords.Continue:
                case Keywords.Delegate:
                case Keywords.Function:
                case Keywords.Inherits:
                case Keywords.Operator:
                case Keywords.Optional:
                case Keywords.Preserve:
                case Keywords.Property:
                case Keywords.ReadOnly:
                case Keywords.SyncLock:
                case Keywords.UInteger:
                case Keywords.Widening:
                    result = keywordLookup[8][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.AddressOf:
                case Keywords.Interface:
                case Keywords.Namespace:
                case Keywords.Narrowing:
                case Keywords.Overloads:
                case Keywords.Overrides:
                case Keywords.Protected:
                case Keywords.Structure:
                case Keywords.WriteOnly:
                    result = keywordLookup[9][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.AddHandler:
                case Keywords.DirectCast:
                case Keywords.Implements:
                case Keywords.ParamArray:
                case Keywords.RaiseEvent:
                case Keywords.WithEvents:
                    result = keywordLookup[10][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.MustInherit:
                case Keywords.Overridable:
                    result = keywordLookup[11][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.RemoveHandler:
                    result = keywordLookup[13][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.Class_Finalize:
                case Keywords.NotInheritable:
                case Keywords.NotOverridable:
                    result = keywordLookup[14][(int)keyWord];
                    goto __keywordEcho;
                case Keywords.Class_Initialize:
                    result = keywordLookup[16][(int)keyWord];
                    goto __keywordEcho;
                default:
                    return null;
            }
        }
        public override void TranslateConceptKeyword(int keyWord)
        {
            this.TranslateConceptKeyword((Keywords)keyWord);
        }

        public override void TranslateComment(IDocumentationComment docComment)
        {
            TranslateConceptComment(docComment.BuildCommentBody(base.Options), true);
        }

        public override void TranslateExpression(IBaseReferenceExpression baseRefExpression)
        {
            TranslateConceptKeyword(Keywords.MyBase);
        }

        public override void TranslateMember<TOperator>(IOperatorOverloadMember<TOperator> operatorOverloadMember)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void TranslateMember(IUnaryOperatorOverloadMember unaryMember)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void TranslateMember(IBinaryOperatorOverloadMember binaryMember)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void TranslateMember(ITypeConversionOverloadMember typeConversionMember)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void TranslateExpression(IUnaryOperationExpression unOpExpression)
        {
            throw new NotImplementedException();
        }

        public override void TranslateStatement(ICrementStatement crementStatement)
        {
            throw new NotImplementedException();
        }

        public override void TranslateAttribute(AttributeTargets target, IAttributeDeclarationTarget attributeSource, IAttributeDeclaration attribute)
        {
            throw new NotImplementedException();
        }

        public override void TranslateStatement(IBlockStatement blockStatement)
        {
            throw new NotImplementedException();
        }

        public override void TranslateStatement(IYieldStatement yieldStatement)
        {
            throw new NotImplementedException();
        }

        public override void TranslateStatement(IYieldBreakStatement breakStatement)
        {
            throw new NotImplementedException();
        }
    }
    #endregion //Oilexer nested types

}