using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Text;
using Oilexer.Comments;
using Oilexer.Types;
using Oilexer.Types.Members;

namespace Oilexer.Translation
{
    public interface IIntermediateCodeTranslator :
        IIntermediateTranslator
    {
        /// <summary>
        /// Returns/sets the <see cref="IndentedTextWriter"/> which is used to export the code.
        /// </summary>
        IndentedTextWriter Target { get; set; }
        /// <summary>
        /// Returns/sets the <see cref="IIntermediateCodeTranslatorOptions"/> which drive the 
        /// code generation process.
        /// </summary>
        IIntermediateCodeTranslatorOptions Options { get; set; }

        /// <summary>
        /// Returns the string which denotes the sub-tool version.  
        /// Relates specifically to the individual language implementation.
        /// </summary>
        string SubToolVersion { get; }
        /// <summary>
        /// Returns the string which denotes the sub-tool's name.
        /// Relates specifically to the individual language implementation.
        /// </summary>
        string SubToolName { get; }
        /// <summary>
        /// Returns the name of the language implemented by the sub-tool.
        /// </summary>
        string Language { get; }
        /// <summary>
        /// Returns the version of the tool.
        /// </summary>
        string ToolVersion { get; }
        /// <summary>
        /// Returns the name of the intermediate foundation.
        /// </summary>
        string ToolName { get; }
        /// <summary>
        /// Returns the 'generated by a tool' text for comments.
        /// </summary>
        string GeneratedMessageText { get; }

        /// <summary>
        /// Returns whether or not the <paramref name="identifier"/> is a keyword.
        /// </summary>
        /// <param name="identifier">The identifier/token to check for keyword status.</param>
        /// <returns>true if the <paramref name="identifier"/> is a keyword in the language
        /// (<see cref="Language"/>).</returns>
        bool IsKeyword(string identifier);

        /// <summary>
        /// Escapes a string so that invalid characters are removed, or escaped, and start/end marks
        /// are added.
        /// </summary>
        /// <param name="value">The value of the string to escape.</param>
        /// <param name="indentLevel">The level of indentation.</param>
        /// <returns>A <see cref="String"/> which represents the <paramref name="value"/> 
        /// in proper escaped form for the language (<see cref="Language"/>).</returns>
        string EscapeString(string value, int indentLevel);

        /// <summary>
        /// Returns an identifier that has been escaped, or translated from a potentially
        /// invalid form to a correct, proper, form.
        /// </summary>
        /// <param name="identifier">The identifier to escape.</param>
        /// <returns>A <see cref="System.String"/> translated from <paramref name="identifier"/>
        /// that is a valid identifier in the language (<see cref="Language"/>).</returns>
        string EscapeIdentifier(string identifier);

        void TranslateConceptAccessModifiers(IDeclaration decl);
        void TranslateConceptTypeName(ITypeReference typeRef);
        void TranslateConceptTypeName(IExternTypeReference type, ITypeReferenceCollection typeParameters);
        void TranslateConceptTypeName(IDeclaredTypeReference type, ITypeReferenceCollection typeParameters);
        void TranslateConceptTypeName(ITypeParameterMember type, ITypeReferenceCollection typeParameters);
        void TranslateConceptIdentifier(string identifierBase, TranslatorFormatterMemberType memberType);
        void TranslateConceptIdentifier(IDeclaration decl);
        void TranslateConceptIdentifier(string identifierBase);
        void TranslateConceptKeyword(int keyWord);

        void TranslateConceptComment(string commentBase, bool docComment);
        void TranslateConceptRegionStart(string regionText);
        void TranslateConceptRegionEnd(string regionText);
        /// <summary>
        /// Translates the 'Partial' concept, if supported.
        /// </summary>
        /// <param name="seggedDecl">The segented declaration which needs the 'partial' keyword
        /// for that language translated to the <see cref="Target"/>.</param>
        void TranslateConceptPartial(ISegmentableDeclarationTarget seggedDecl);
        /// <summary>
        /// Translates the 'NotInstantiable'/'abstract' concept.
        /// </summary>
        /// <param name="classType"></param>
        void TranslateConceptNotInstantiableClass(IClassType classType);
        /// <summary>
        /// Translates the 'NotInheritable'/'sealed' concept.
        /// </summary>
        /// <param name="classType">The <see cref="IClassType"/> which is not inheritable, i.e. sealed.</param>
        void TranslateConceptNotInheritableClass(IClassType classType);
        /// <summary>
        /// Translates the [NotInheritable/Module]/static concept
        /// </summary>
        /// <param name="classType"><para>The <see cref="IClassType"/> that, if top-level and not segmented across multiple files, is a VB Module.</para>
        /// <para>In C# this is a 'static' class.</para></param>
        void TranslateConceptNotInheritableOrInstantiableClass(IClassType classType);

        void TranslateComment(IComment comment);
        void TranslateComments(IComments comments);
        void TranslateComment(IDocumentationComment docComment);

    }
}
